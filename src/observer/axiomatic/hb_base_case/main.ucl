/**
 * A manually written model exploring the following concepts:
 * 1. A good set of timer-related axioms
 * 1. (TODO) Individual trace variable for each component with a starting point.
 * 2. (TODO) a HB definition consistent with Lamport's def.
 * 3. (TODO) a full-blown three timers example that illustrate frames of reference.
 */
module main {
 
    type    * = common.*;
    define  * = common.*;
    const   * = common.*;
     
    // Mark the start of the trace.
    var start : timestamp_t;
    assume(start == 0);

    // The trace of a1
    var trace : trace_t;

    // Helper macro that returns an element based on index
    define elem(i : integer) : element_t
    = get(trace, i);

    /********************************
     * The Happened-Before Relation *
     *******************************/
    // Original:
    // hb(a,b) := g(a) + min(sum(max(edge_weight))) <= g(b)

    // Now taking a path-based approach.
    // Lamport: hb(a,b) := exists (p : path) :: reach(a, path) == b;

    // Check individual hb edges:
    // 1. If two invocations are in the same federate, compare tags directly.
    // 2. If two invocations belong to different federates, check if there exists
    //      a connection with a logical delay.

    // Return reaction priority.
    define priority(i : id_t) : integer
    = if (i == a1) then 1 else (
        if (i == b1) then 1 else (
            if (i == b2) then 2 else (
                if (i == b3) then 3 else (
                    999))));

    // Return logical delay in a connection.
    define connection_delay(i1, i2 : id_t) : interval_t
    = if (i1 == a1 && i2 == b3) then msec(10) else inf(); 

    define _hb_same_fed(e1, e2 : element_t) : boolean
    = tag_earlier(g(e1), g(e2)) ||
        (tag_same(g(e1), g(e2)) && priority(id(e1)) < priority(id(e2)));

    define _hb_diff_fed(e1, e2 : element_t) : boolean
    = tag_earlier(tag_delay(g(e1), connection_delay(id(e1), id(e2))), g(e2))
        || tag_same(tag_delay(g(e1), connection_delay(id(e1), id(e2))), g(e2));

    define _hb(e1, e2 : element_t) : boolean
    =   // If two events belong to the same federate,
        // determine hb via tags.
        // This is bi-directional.
        (( (id(e1) == id(e2))
        || (id(e1) == b1 && id(e2) == b2)
        || (id(e1) == b2 && id(e2) == b1)
        || (id(e1) == b1 && id(e2) == b3)
        || (id(e1) == b3 && id(e2) == b1)
        || (id(e1) == b2 && id(e2) == b3)
        || (id(e1) == b3 && id(e2) == b2))
            ==> _hb_same_fed(e1, e2))
        // If two events belong to different federates,
        // check if a connection is present.
        // This is uni-directional.
        && (((id(e1) == a1 && id(e2) == b3))
            ==> _hb_diff_fed(e1, e2));

    // Check if a path (with 2 edges, in this case,) exists
    define hb(e1, e2 : element_t) : boolean
    = exists (a, b, c : integer) :: elem(a) == e1 && elem(b) == e2 &&   // Link e1, e2 to the start and end of a path.
        _hb(elem(a), elem(b)) && _hb(elem(b), elem(c));                 // Check if a path between e1 and e2 exists.

    
    /*****************
     * Helper Macros *
     *****************/
    define is_multiple_of(a, b : integer) : boolean
    = exists (c : integer) :: b * c == a;

    define is_closest_starting_point(now : tag_t, period : integer, offset : integer) : boolean
    = (exists (c : integer) :: (period * c) + offset == pi1(now)
        // Tick at the next valid instant.
        && (period * (c - 1) + offset) < start)     
        // Timer always has mstep of 0.
        && pi2(now) == 0;                           

    // first & last in trace
    define first(e : element_t) : boolean
    = !(exists (i : integer) :: in_range(i) && id(elem(i)) == id(e) && tag_earlier(g(elem(i)), g(e))); 

    define last(e : element_t) : boolean
    = !(exists (i : integer) :: in_range(i) && id(elem(i)) == id(e) && tag_later(g(elem(i)), g(e))); 

    define is_triggered_by_startup(_id : id_t) : boolean
    = // If startup is within frame, put the events in the trace.
    ((start == 0) ==> (exists (i : integer) :: in_range(i)
        && id(elem(i)) == _id && tag_same(g(elem(i)), startup())))
    // Can only appear once.
    && !(exists (j : integer) :: in_range(j) && id(elem(j)) == _id
        && !tag_same(g(elem(j)), startup()));
    
    define is_triggered_by(downstream, upstream : id_t, delay : interval_t) : boolean
    = (forall (i : integer) :: in_range(i) ==>
        id(elem(i)) == downstream ==> (exists (j : integer) :: in_range(j)
            && id(elem(j)) == upstream 
            && g(elem(i)) == tag_schedule(g(elem(j)), delay))
    );

    define is_in_trace(_id : id_t) : boolean
    = (exists (i : integer) :: in_range(i) && id(elem(i)) == _id);

    /**********
     * Axioms *
     **********/
    // Display trace in timestamp order
    axiom(forall (i, j : integer) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(elem(i)), g(elem(j)))
            || tag_same(g(elem(i)), g(elem(j)))));
    
    // All microsteps are positive
    axiom(forall (i : integer) :: in_range(i)
        ==> pi2(g(elem(i))) >= 0);

    // The same event can only trigger once in a logical instant
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j))
        ==> ((id(elem(i)) == id(elem(j)) && i != j)
            ==> !tag_same(g(elem(i)), g(elem(j)))));

    // NULL events should appear in the suffix
    axiom(forall (j : integer) :: in_range(j) ==> (
        (id(elem(j)) != NULL) ==> (forall (i : integer) :: in_range(i) ==> 
        ((i < j) ==> id(elem(i)) != NULL)
    )));

    // [Only for timers] The trace should not have NULL events
    // axiom(forall (i : integer) :: in_range(i)
    //     ==> !isNULL(elem(i)));
    
    // All tags should be positive
    axiom(forall (i : integer) :: in_range(i) ==> (
        pi1(g(elem(i))) >= 0
    ));

    // Begin the frame at the start time specified.
    axiom(forall (i : integer) :: tag_same(g(elem(i)), {start, 0})
        || tag_later(g(elem(i)), {start, 0}));
    
    // [Important] The trace should respect the HB relation.
    // axiom(forall (i, j : integer) :: hb(elem(i), elem(j))
    //     ==> i < j);

    /*******************************
     * Application-specific axioms *
     *******************************/
    // a1 triggered by startup.
    axiom(is_triggered_by_startup(a1));

    // b1 triggered by startup.
    axiom(is_triggered_by_startup(b1));

    // b2 is triggered by the logical action scheduled by b1.
    axiom(is_triggered_by(b2, b1, msec(9)));

    // b3 is triggered by a1 with logical delay of 10 msec.
    axiom(is_triggered_by(b3, a1, msec(10)));

     
    // [placeholder] Add user-defined properties here.
    property test : !(is_in_trace(b3) && is_in_trace(b2));

    // property test : false;
     
    //////////////////////////////////////////////////
     
    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex;
    }
     
}

    /**************
     * Backburner *
     **************/
    /*
    // first & last in trace_t1
    define first(e : element_t) : boolean
    = !(exists (i : integer) :: id(elem_t1(i)) == id(e) && tag_earlier(g(elem_t1(i)), g(e))); 

    define last(e : element_t) : boolean
    = !(exists (i : integer) :: id(elem_t1(i)) == id(e) && tag_later(g(elem_t1(i)), g(e))); 
    */

    // (Might not be a good thing to have, since we want to check unbounded props.)
    // First invocation of A2 should start at 2 ms.

    // Display simulatenous elements in order of priority
     
    // Startup should only appears once in each reactor
