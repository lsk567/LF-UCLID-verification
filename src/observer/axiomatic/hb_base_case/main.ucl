/**
 * A manually written model exploring the following concepts:
 * 1. A good set of timer-related axioms
 * 1. (TODO) Individual trace variable for each component with a starting point.
 * 2. (TODO) a HB definition consistent with Lamport's def.
 * 3. (TODO) a full-blown three timers example that illustrate frames of reference.
 */
module main {
 
    type    * = common.*;
    define  * = common.*;
    const   * = common.*;
     
    // Mark the start of the trace.
    var start : timestamp_t;
    assume(start >= 1000000000001);

    // The trace of a1
    var trace : trace_t;

    // Helper macro that returns an element based on index
    define elem(i : integer) : element_t
    = get(trace, i);

    /********************************
     * The Happened-Before Relation *
     *******************************/
    // Original:
    // hb(a,b) := g(a) + min(sum(max(edge_weight))) <= g(b)

    // Now taking a path-based approach.
    // Lamport: hb(a,b) := exists (p : path) :: reach(a, path) == b;

    // Check individual hb edges:
    // 1. If two invocations are in the same federate, compare tags directly.
    // 2. If two invocations belong to different federates, check if there exists
    //      a connection with a logical delay.

    // Return reaction priority.
    define priority(i : id_t) : integer
    = if (i == a1) then 1 else (
        if (i == a2) then 2 else (
            if (i == b1) then 1 else (
                if (i == b2) then 2 else (
                    999))));

    // Return logical delay in a connection.
    define connection_delay(i1, i2 : id_t) : interval_t
    = if (i1 == a2 && i2 == b2) then msec(1) else inf(); 

    define _hb_same_fed(e1, e2 : element_t) : boolean
    = tag_earlier(g(e1), g(e2)) ||
        (tag_same(g(e1), g(e2)) && priority(id(e1)) < priority(id(e2)));

    define _hb_diff_fed(e1, e2 : element_t) : boolean
    = tag_earlier(tag_delay(g(e1), connection_delay(id(e1), id(e2))))
        || tag_same(tag_delay(g(e1), connection_delay(id(e1), id(e2))));

    define _hb(e1, e2 : element_t) : boolean
    =   // If two events belong to the same federate,
        // determine hb via tags.
        (((id(e1) == a1 && id(e2) == a2)
        || (id(e1) == a2 && id(e2) == a1)
        || (id(e1) == b1 && id(e2) == b2)
        || (id(e1) == b2 && id(e2) == b1))
            ==> _hb_same_fed(e1, e2))
        // If two events belong to different federates,
        // check if a connection is present.
        && (((id(e1) == a2 && id(e2) == b2))
            ==> _hb_diff_fed(e1, e2));

    // Check if a path (with 2 edges, in this case,) exists
    define hb(e1, e2 : element_t) : boolean
    = exists (a, b, c : integer) :: elem(a) == e1 && elem(b) == e2 &&   // Link e1, e2 to the start and end of a path.
        _hb(elem(a), elem(b)) && _hb(elem(b), elem(c));                 // Check if a path between e1 and e2 exists.

    
    /*****************
     * Helper Macros *
     *****************/
    define is_multiple_of(a, b : integer) : boolean
    = exists (c : integer) :: b * c == a;

    define is_closest_starting_point(now : tag_t, period : integer, offset : integer) : boolean
    = (exists (c : integer) :: (period * c) + offset == pi1(now)
        // Tick at the next valid instant.
        && (period * (c - 1) + offset) < start)     
        // Timer always has mstep of 0.
        && pi2(now) == 0;                           

    // first & last in trace
    define first(e : element_t) : boolean
    = !(exists (i : integer) :: in_range(i) && id(elem(i)) == id(e) && tag_earlier(g(elem(i)), g(e))); 

    define last(e : element_t) : boolean
    = !(exists (i : integer) :: in_range(i) && id(elem(i)) == id(e) && tag_later(g(elem(i)), g(e))); 
    
    /**********
     * Axioms *
     **********/
    // Display trace in timestamp order
    axiom(forall (i, j : integer) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(elem(i)), g(elem(j)))
            || tag_same(g(elem(i)), g(elem(j)))));
    
    // All microsteps are positive
    axiom(forall (i : integer) :: in_range(i)
        ==> pi2(g(elem(i))) >= 0);

    // The same event can only trigger once in a logical instant
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j))
        ==> ((id(elem(i)) == id(elem(j)) && i != j)
            ==> !tag_same(g(elem(i)), g(elem(j)))));

    /*
    // NULL events should appear in the suffix
    axiom(forall (j : integer) :: in_range(j) ==> (
        (id(elem(j)) != NULL) ==> (forall (i : integer) :: in_range(i) ==> 
        ((i < j) ==> id(elem(i)) != NULL)
    )));
    */

    // The trace should not have NULL events
    axiom(forall (i : integer) :: in_range(i)
        ==> !isNULL(elem(i)));
    
    // [Updated] All tags should be positive
    axiom(forall (i : integer) :: in_range(i) ==> (
        pi1(g(elem(i))) >= 0
    ));

    // Begin the frame at the start time specified.
    axiom(forall (i : integer) :: tag_same(g(elem(i)), {start, 0})
        || tag_later(g(elem(i)), {start, 0}));
    
    // Each reaction should have a preceding reaction that triggered it.

    // 1. start the firing at the first valid instant closest to the start.
    // axiom(is_closest_starting_point(g(elem(0)), pi1(msec(10)), pi1(msec(20))));

    // 2. each subsequent firing is separated by the period.
    // (FIXME: Need to finish.)
    /*
    axiom(forall (i : integer) :: in_range(i)
        ==> (
            // (first(elem(i)) ==> is_closest_starting_point(g(elem(i)), pi1(msec(10)), pi1(msec(20))))
            // (i == 0 ==> is_closest_starting_point(g(elem(i)), pi1(msec(10)), pi1(msec(20))))
            // && (!first(elem(i)) ==> (g(elem(i)) == tag_schedule(g(elem(i-1)), msec(10))))
        ));
    */

    /*    
    // Each reaction should have a preceding reaction that triggered it.

    // 1. start the firing at the first valid instant closest to the start.
    axiom(is_closest_starting_point(g(elem_a2(0)), pi1(msec(10)), 0));

    // 2. each subsequent firing is separated by the period.
    axiom(forall (i : integer) :: (in_range(i) && i > 0)
        ==> (g(elem_a2(i)) == tag_schedule(g(elem_a2(i-1)), msec(10))));


    
    // Each reaction should have a preceding reaction that triggered it.

    // 1. start the firing at the first valid instant closest to the start.
    axiom(is_closest_starting_point(g(elem_b1(0)), pi1(msec(12)), 0));

    // 2. each subsequent firing is separated by the period.
    axiom(forall (i : integer) :: (in_range(i) && i > 0)
        ==> (g(elem_b1(i)) == tag_schedule(g(elem_b1(i-1)), msec(12))));



    // For every invocation of b2, there needs to be an instance of a2 upstream.
    axiom(forall (i : integer) :: !isNULL(elem_b2(i))
        ==> (exists (j : integer) :: !isNULL(elem_a2(j))
            && g(elem_b2(i)) == tag_delay(g(elem_a2(j)), msec(1))
        )
    );
    */


    /**************
     * Backburner *
     **************/
    /*
    // first & last in trace_t1
    define first(e : element_t) : boolean
    = !(exists (i : integer) :: id(elem_t1(i)) == id(e) && tag_earlier(g(elem_t1(i)), g(e))); 

    define last(e : element_t) : boolean
    = !(exists (i : integer) :: id(elem_t1(i)) == id(e) && tag_later(g(elem_t1(i)), g(e))); 
    */

    // (Might not be a good thing to have, since we want to check unbounded props.)
    // First invocation of A2 should start at 2 ms.

    // Display simulatenous elements in order of priority
     
    // Startup should only appears once in each reactor
     
    // [placeholder] Add user-defined properties here.
    // property test : !(exists (i : integer) :: in_range(i) && id(elem_a1(i)) == a1);

    property test : false;
     
    //////////////////////////////////////////////////
     
    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex;
    }
     
}
