// Code generated by the Lingua Franca compiler from file:
// /Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf
#include "pqueue.c"
#define NUMBER_OF_FEDERATES 1
#include "reactor.c"
// =============== START reactor class Arith
typedef struct {
    #line 7 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int* __dbl;
    #line 7 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool* __dbl_is_present;
    #line 8 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int* __incr;
    #line 8 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool* __incr_is_present;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __relay;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool __relay_is_present;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __relay_num_destinations;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[1];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[1];
    int __reaction_0_triggered_sizes[1];
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_1;
    bool* __reaction_1_outputs_are_present[1];
    int __reaction_1_num_outputs;
    trigger_t** __reaction_1_triggers[1];
    int __reaction_1_triggered_sizes[1];
    #line 7 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    trigger_t ___dbl;
    #line 7 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t* ___dbl_reactions[1];
    #line 8 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    trigger_t ___incr;
    #line 8 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t* ___incr_reactions[1];
} arith_self_t;
void arithreaction_function_0(void* instance_args) {
    arith_self_t* self = (arith_self_t*)instance_args;
    bool dbl_is_present = *(self->__dbl_is_present);
    int dbl;
    if (dbl_is_present) {
                           dbl = *(self->__dbl);
    }
    int* relay = &(self->__relay);
    bool relay_is_present = self->__relay_is_present;
    #line 12 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int v = dbl;
            v *= 2;
            set(relay, v);
        
}
void arithreaction_function_1(void* instance_args) {
    arith_self_t* self = (arith_self_t*)instance_args;
    bool incr_is_present = *(self->__incr_is_present);
    int incr;
    if (incr_is_present) {
                           incr = *(self->__incr);
    }
    int* relay = &(self->__relay);
    bool relay_is_present = self->__relay_is_present;
    #line 18 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int v = incr;
            v += 1;
            set(relay, v);
        
}
arith_self_t* new_Arith() {
    arith_self_t* self = (arith_self_t*)calloc(1, sizeof(arith_self_t));
    self->__reaction_0_outputs_are_present[0] = &self->__relay_is_present;
    self->__reaction_0_num_outputs = 1;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.function = arithreaction_function_0;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.self = self;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.num_outputs = 1;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    #line 11 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    self->__reaction_1_outputs_are_present[0] = &self->__relay_is_present;
    self->__reaction_1_num_outputs = 1;
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.function = arithreaction_function_1;
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.self = self;
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.num_outputs = 1;
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.output_produced = self->__reaction_1_outputs_are_present;
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggered_sizes = self->__reaction_1_triggered_sizes;
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggers = self->__reaction_1_triggers;
    #line 17 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 7 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___dbl.scheduled = NEVER;
    #line 7 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___dbl_reactions[0] = &self->___reaction_0;
    self->___dbl.reactions = &self->___dbl_reactions[0];
    self->___dbl.number_of_reactions = 1;
    self->___dbl.element_size = sizeof(int);
    #line 8 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___incr.scheduled = NEVER;
    #line 8 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___incr_reactions[0] = &self->___reaction_1;
    self->___incr.reactions = &self->___incr_reactions[0];
    self->___incr.number_of_reactions = 1;
    self->___incr.element_size = sizeof(int);
    return self;
}
// =============== END reactor class Arith

// =============== START reactor class Relay
typedef struct {
    #line 25 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int* __r;
    #line 25 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool* __r_is_present;
    #line 26 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int* __in2;
    #line 26 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool* __in2_is_present;
    #line 27 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __out;
    #line 27 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool __out_is_present;
    #line 27 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __out_num_destinations;
    #line 28 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __out2;
    #line 28 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool __out2_is_present;
    #line 28 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __out2_num_destinations;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[1];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[1];
    int __reaction_0_triggered_sizes[1];
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_1;
    bool* __reaction_1_outputs_are_present[1];
    int __reaction_1_num_outputs;
    trigger_t** __reaction_1_triggers[1];
    int __reaction_1_triggered_sizes[1];
    #line 25 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    trigger_t ___r;
    #line 25 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t* ___r_reactions[1];
    #line 26 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    trigger_t ___in2;
    #line 26 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t* ___in2_reactions[1];
} relay_self_t;
void relayreaction_function_0(void* instance_args) {
    relay_self_t* self = (relay_self_t*)instance_args;
    bool r_is_present = *(self->__r_is_present);
    int r;
    if (r_is_present) {
                           r = *(self->__r);
    }
    int* out = &(self->__out);
    bool out_is_present = self->__out_is_present;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    set(out, r);
        
}
void relayreaction_function_1(void* instance_args) {
    relay_self_t* self = (relay_self_t*)instance_args;
    bool in2_is_present = *(self->__in2_is_present);
    int in2;
    if (in2_is_present) {
                           in2 = *(self->__in2);
    }
    int* out2 = &(self->__out2);
    bool out2_is_present = self->__out2_is_present;
    #line 34 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    set(out2, in2);
        
}
relay_self_t* new_Relay() {
    relay_self_t* self = (relay_self_t*)calloc(1, sizeof(relay_self_t));
    self->__reaction_0_outputs_are_present[0] = &self->__out_is_present;
    self->__reaction_0_num_outputs = 1;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.function = relayreaction_function_0;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.self = self;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.num_outputs = 1;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    self->__reaction_1_outputs_are_present[0] = &self->__out2_is_present;
    self->__reaction_1_num_outputs = 1;
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.function = relayreaction_function_1;
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.self = self;
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.num_outputs = 1;
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.output_produced = self->__reaction_1_outputs_are_present;
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggered_sizes = self->__reaction_1_triggered_sizes;
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggers = self->__reaction_1_triggers;
    #line 33 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 25 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___r.scheduled = NEVER;
    #line 25 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___r_reactions[0] = &self->___reaction_0;
    self->___r.reactions = &self->___r_reactions[0];
    self->___r.number_of_reactions = 1;
    self->___r.element_size = sizeof(int);
    #line 26 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in2.scheduled = NEVER;
    #line 26 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in2_reactions[0] = &self->___reaction_1;
    self->___in2.reactions = &self->___in2_reactions[0];
    self->___in2.number_of_reactions = 1;
    self->___in2.element_size = sizeof(int);
    return self;
}
// =============== END reactor class Relay

// =============== START reactor class Reset
typedef struct {
    #line 39 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int* __in;
    #line 39 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool* __in_is_present;
    #line 40 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __dbl;
    #line 40 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool __dbl_is_present;
    #line 40 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __dbl_num_destinations;
    #line 41 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __incr;
    #line 41 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool __incr_is_present;
    #line 41 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __incr_num_destinations;
    #line 42 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __out;
    #line 42 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool __out_is_present;
    #line 42 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int __out_num_destinations;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[2];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[2];
    int __reaction_0_triggered_sizes[2];
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_1;
    bool* __reaction_1_outputs_are_present[1];
    int __reaction_1_num_outputs;
    trigger_t** __reaction_1_triggers[1];
    int __reaction_1_triggered_sizes[1];
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    #line 39 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    trigger_t ___in;
    #line 39 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t* ___in_reactions[1];
} reset_self_t;
void resetreaction_function_0(void* instance_args) {
    reset_self_t* self = (reset_self_t*)instance_args;
    int* dbl = &(self->__dbl);
    bool dbl_is_present = self->__dbl_is_present;
    int* incr = &(self->__incr);
    bool incr_is_present = self->__incr_is_present;
    #line 44 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    set(incr, 1);
    set(dbl, 1);
        
}
void resetreaction_function_1(void* instance_args) {
    reset_self_t* self = (reset_self_t*)instance_args;
    bool in_is_present = *(self->__in_is_present);
    int in;
    if (in_is_present) {
                           in = *(self->__in);
    }
    int* out = &(self->__out);
    bool out_is_present = self->__out_is_present;
    #line 48 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    // reset 
    set(out, 0);
        
}
reset_self_t* new_Reset() {
    reset_self_t* self = (reset_self_t*)calloc(1, sizeof(reset_self_t));
    self->__reaction_0_outputs_are_present[0] = &self->__dbl_is_present;
    self->__reaction_0_outputs_are_present[1] = &self->__incr_is_present;
    self->__reaction_0_num_outputs = 2;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.function = resetreaction_function_0;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.self = self;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.num_outputs = 2;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    #line 43 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    self->__reaction_1_outputs_are_present[0] = &self->__out_is_present;
    self->__reaction_1_num_outputs = 1;
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.function = resetreaction_function_1;
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.self = self;
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.num_outputs = 1;
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.output_produced = self->__reaction_1_outputs_are_present;
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggered_sizes = self->__reaction_1_triggered_sizes;
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggers = self->__reaction_1_triggers;
    #line 47 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___startup.scheduled = NEVER;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = true;
    #line 39 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in.scheduled = NEVER;
    #line 39 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in_reactions[0] = &self->___reaction_1;
    self->___in.reactions = &self->___in_reactions[0];
    self->___in.number_of_reactions = 1;
    self->___in.element_size = sizeof(int);
    return self;
}
// =============== END reactor class Reset

// =============== START reactor class Out
typedef struct {
    #line 54 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int* __in;
    #line 54 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool* __in_is_present;
    #line 55 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    int* __in2;
    #line 55 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    bool* __in2_is_present;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[0];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[0];
    int __reaction_0_triggered_sizes[0];
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t ___reaction_1;
    bool* __reaction_1_outputs_are_present[0];
    int __reaction_1_num_outputs;
    trigger_t** __reaction_1_triggers[0];
    int __reaction_1_triggered_sizes[0];
    #line 54 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    trigger_t ___in;
    #line 54 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t* ___in_reactions[1];
    #line 55 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    trigger_t ___in2;
    #line 55 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    reaction_t* ___in2_reactions[1];
} out_self_t;
void outreaction_function_0(void* instance_args) {
    out_self_t* self = (out_self_t*)instance_args;
    bool in_is_present = *(self->__in_is_present);
    int in;
    if (in_is_present) {
                           in = *(self->__in);
    }
    #line 57 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    printf("Current value (in) is: %d\n", in);    
        
}
void outreaction_function_1(void* instance_args) {
    out_self_t* self = (out_self_t*)instance_args;
    bool in2_is_present = *(self->__in2_is_present);
    int in2;
    if (in2_is_present) {
                           in2 = *(self->__in2);
    }
    #line 60 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    printf("Current value (in2) is: %d\n", in2);    
        
}
out_self_t* new_Out() {
    out_self_t* self = (out_self_t*)calloc(1, sizeof(out_self_t));
    self->__reaction_0_num_outputs = 0;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.function = outreaction_function_0;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.self = self;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.num_outputs = 0;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    #line 56 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    self->__reaction_1_num_outputs = 0;
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.function = outreaction_function_1;
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.self = self;
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.num_outputs = 0;
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.output_produced = self->__reaction_1_outputs_are_present;
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggered_sizes = self->__reaction_1_triggered_sizes;
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.triggers = self->__reaction_1_triggers;
    #line 59 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 54 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in.scheduled = NEVER;
    #line 54 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in_reactions[0] = &self->___reaction_0;
    self->___in.reactions = &self->___in_reactions[0];
    self->___in.number_of_reactions = 1;
    self->___in.element_size = sizeof(int);
    #line 55 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in2.scheduled = NEVER;
    #line 55 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith_delay.lf"
    self->___in2_reactions[0] = &self->___reaction_1;
    self->___in2.reactions = &self->___in2_reactions[0];
    self->___in2.number_of_reactions = 1;
    self->___in2.element_size = sizeof(int);
    return self;
}
// =============== END reactor class Out

// =============== START reactor class __GenDelay_197ef
typedef struct {
    interval_t delay;
    int* __inp;
    bool* __inp_is_present;
    int __out;
    bool __out_is_present;
    int __out_num_destinations;
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[1];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[1];
    int __reaction_0_triggered_sizes[1];
    reaction_t ___reaction_1;
    bool* __reaction_1_outputs_are_present[0];
    int __reaction_1_num_outputs;
    trigger_t** __reaction_1_triggers[0];
    int __reaction_1_triggered_sizes[0];
    trigger_t ___act;
    reaction_t* ___act_reactions[1];
    trigger_t ___inp;
    reaction_t* ___inp_reactions[1];
} __gendelay_197ef_self_t;
void __gendelay_197efreaction_function_0(void* instance_args) {
    __gendelay_197ef_self_t* self = (__gendelay_197ef_self_t*)instance_args;
    bool act_is_present = self->___act.is_present;
    bool act_has_value = ((self->___act.token) != NULL && (self->___act.token)->value != NULL);
    token_t* act_token = (self->___act.token);
    int act_value;
    if (act_has_value) {
        act_value = *((int*)(self->___act.token)->value);
    }
    int* out = &(self->__out);
    bool out_is_present = self->__out_is_present;
    set(out, act_value);
}
void __gendelay_197efreaction_function_1(void* instance_args) {
    __gendelay_197ef_self_t* self = (__gendelay_197ef_self_t*)instance_args;
    bool inp_is_present = *(self->__inp_is_present);
    int inp;
    if (inp_is_present) {
                           inp = *(self->__inp);
    }
    trigger_t* act = &self->___act;
    schedule_copy(act, 0, &inp, 1);  // Length is 1.
}
__gendelay_197ef_self_t* new___GenDelay_197ef() {
    __gendelay_197ef_self_t* self = (__gendelay_197ef_self_t*)calloc(1, sizeof(__gendelay_197ef_self_t));
    self->__reaction_0_outputs_are_present[0] = &self->__out_is_present;
    self->__reaction_0_num_outputs = 1;
    self->___reaction_0.function = __gendelay_197efreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.num_outputs = 1;
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->__reaction_1_num_outputs = 0;
    self->___reaction_1.function = __gendelay_197efreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.num_outputs = 0;
    self->___reaction_1.output_produced = self->__reaction_1_outputs_are_present;
    self->___reaction_1.triggered_sizes = self->__reaction_1_triggered_sizes;
    self->___reaction_1.triggers = self->__reaction_1_triggers;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___act.scheduled = NEVER;
    self->___act_reactions[0] = &self->___reaction_0;
    self->___act.reactions = &self->___act_reactions[0];
    self->___act.number_of_reactions = 1;
    self->___act.is_physical = false;
    self->___act.drop = false;
    self->___act.element_size = sizeof(int);
    self->___inp.scheduled = NEVER;
    self->___inp_reactions[0] = &self->___reaction_1;
    self->___inp.reactions = &self->___inp_reactions[0];
    self->___inp.number_of_reactions = 1;
    self->___inp.element_size = sizeof(int);
    return self;
}
// =============== END reactor class __GenDelay_197ef

// =============== START reactor class Composite
typedef struct {
    bool hasContents;
} composite_self_t;
composite_self_t* new_Composite() {
    composite_self_t* self = (composite_self_t*)calloc(1, sizeof(composite_self_t));
    return self;
}
// =============== END reactor class Composite

void __set_default_command_line_options() {
}
// Array of pointers to timer triggers to start the timers in __start_timers().
trigger_t* __timer_triggers[1];
int __timer_triggers_size = 1;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 5;
    __tokens_with_ref_count = (token_present_t*)malloc(5 * sizeof(token_present_t));
    // Create the array that will contain pointers to _is_present fields to reset on each step.
    __is_present_fields_size = 11;
    __is_present_fields = (bool**)malloc(11 * sizeof(bool*));
    // ************* Instance Composite of class Composite
    composite_self_t* composite_self = new_Composite();
    //***** Start initializing Composite
    // ************* Instance Composite.arith of class Arith
    arith_self_t* composite_arith_self = new_Arith();
    //***** Start initializing Composite.arith
    // Reaction 0 of Composite.arith triggers 1 downstream reactions through port Composite.arith.relay.
    composite_arith_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.arith, allocate an
    // array of trigger pointers for downstream reactions through port Composite.arith.relay
    trigger_t** composite_arith_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_arith_self->___reaction_0.triggers[0] = composite_arith_0_0;
    // Reaction 1 of Composite.arith triggers 1 downstream reactions through port Composite.arith.relay.
    composite_arith_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of Composite.arith, allocate an
    // array of trigger pointers for downstream reactions through port Composite.arith.relay
    trigger_t** composite_arith_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_arith_self->___reaction_1.triggers[0] = composite_arith_1_0;
    composite_arith_self->__relay_num_destinations = 1;
    //***** End initializing Composite.arith
    // ************* Instance Composite.relay of class Relay
    relay_self_t* composite_relay_self = new_Relay();
    //***** Start initializing Composite.relay
    // Reaction 0 of Composite.relay triggers 2 downstream reactions through port Composite.relay.out.
    composite_relay_self->___reaction_0.triggered_sizes[0] = 2;
    // For reaction 0 of Composite.relay, allocate an
    // array of trigger pointers for downstream reactions through port Composite.relay.out
    trigger_t** composite_relay_0_0 = (trigger_t**)malloc(2 * sizeof(trigger_t*));
    composite_relay_self->___reaction_0.triggers[0] = composite_relay_0_0;
    // Reaction 1 of Composite.relay triggers 1 downstream reactions through port Composite.relay.out2.
    composite_relay_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of Composite.relay, allocate an
    // array of trigger pointers for downstream reactions through port Composite.relay.out2
    trigger_t** composite_relay_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_relay_self->___reaction_1.triggers[0] = composite_relay_1_0;
    composite_relay_self->__out_num_destinations = 2;
    composite_relay_self->__out2_num_destinations = 1;
    //***** End initializing Composite.relay
    // ************* Instance Composite.reset of class Reset
    reset_self_t* composite_reset_self = new_Reset();
    //***** Start initializing Composite.reset
    // Reaction 0 of Composite.reset triggers 1 downstream reactions through port Composite.reset.incr.
    composite_reset_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.reset, allocate an
    // array of trigger pointers for downstream reactions through port Composite.reset.incr
    trigger_t** composite_reset_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_reset_self->___reaction_0.triggers[0] = composite_reset_0_0;
    // Reaction 0 of Composite.reset triggers 1 downstream reactions through port Composite.reset.dbl.
    composite_reset_self->___reaction_0.triggered_sizes[1] = 1;
    // For reaction 0 of Composite.reset, allocate an
    // array of trigger pointers for downstream reactions through port Composite.reset.dbl
    trigger_t** composite_reset_0_1 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_reset_self->___reaction_0.triggers[1] = composite_reset_0_1;
    // Reaction 1 of Composite.reset triggers 1 downstream reactions through port Composite.reset.out.
    composite_reset_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of Composite.reset, allocate an
    // array of trigger pointers for downstream reactions through port Composite.reset.out
    trigger_t** composite_reset_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_reset_self->___reaction_1.triggers[0] = composite_reset_1_0;
    composite_reset_self->___startup.offset = 0;
    composite_reset_self->___startup.period = 0;
    __timer_triggers[0] = &composite_reset_self->___startup;
    composite_reset_self->__dbl_num_destinations = 1;
    composite_reset_self->__incr_num_destinations = 1;
    composite_reset_self->__out_num_destinations = 1;
    //***** End initializing Composite.reset
    // ************* Instance Composite.out of class Out
    out_self_t* composite_out_self = new_Out();
    //***** Start initializing Composite.out
    //***** End initializing Composite.out
    // ************* Instance Composite.delay of class __GenDelay_197ef
    __gendelay_197ef_self_t* composite_delay_self = new___GenDelay_197ef();
    //***** Start initializing Composite.delay
    composite_delay_self->delay = MSEC(2);
    // Reaction 0 of Composite.delay triggers 1 downstream reactions through port Composite.delay.out.
    composite_delay_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.delay, allocate an
    // array of trigger pointers for downstream reactions through port Composite.delay.out
    trigger_t** composite_delay_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_delay_self->___reaction_0.triggers[0] = composite_delay_0_0;
    composite_delay_self->___act.offset = MSEC(2);
    composite_delay_self->___act.period = 0;
    composite_delay_self->__out_num_destinations = 1;
    composite_delay_self->___act.token = __create_token(sizeof(int));
    composite_delay_self->___act.is_present = false;
    __tokens_with_ref_count[0].token
            = &composite_delay_self->___act.token;
    __tokens_with_ref_count[0].is_present
            = &composite_delay_self->___act.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    //***** End initializing Composite.delay
    // ************* Instance Composite.delay_0 of class __GenDelay_197ef
    __gendelay_197ef_self_t* composite_delay_0_self = new___GenDelay_197ef();
    //***** Start initializing Composite.delay_0
    composite_delay_0_self->delay = MSEC(1);
    // Reaction 0 of Composite.delay_0 triggers 1 downstream reactions through port Composite.delay_0.out.
    composite_delay_0_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.delay_0, allocate an
    // array of trigger pointers for downstream reactions through port Composite.delay_0.out
    trigger_t** composite_delay_0_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_delay_0_self->___reaction_0.triggers[0] = composite_delay_0_0_0;
    composite_delay_0_self->___act.offset = MSEC(1);
    composite_delay_0_self->___act.period = 0;
    composite_delay_0_self->__out_num_destinations = 1;
    composite_delay_0_self->___act.token = __create_token(sizeof(int));
    composite_delay_0_self->___act.is_present = false;
    __tokens_with_ref_count[1].token
            = &composite_delay_0_self->___act.token;
    __tokens_with_ref_count[1].is_present
            = &composite_delay_0_self->___act.is_present;
    __tokens_with_ref_count[1].reset_is_present = true;
    //***** End initializing Composite.delay_0
    // ************* Instance Composite.delay_1 of class __GenDelay_197ef
    __gendelay_197ef_self_t* composite_delay_1_self = new___GenDelay_197ef();
    //***** Start initializing Composite.delay_1
    composite_delay_1_self->delay = MSEC(1);
    // Reaction 0 of Composite.delay_1 triggers 1 downstream reactions through port Composite.delay_1.out.
    composite_delay_1_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.delay_1, allocate an
    // array of trigger pointers for downstream reactions through port Composite.delay_1.out
    trigger_t** composite_delay_1_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_delay_1_self->___reaction_0.triggers[0] = composite_delay_1_0_0;
    composite_delay_1_self->___act.offset = MSEC(1);
    composite_delay_1_self->___act.period = 0;
    composite_delay_1_self->__out_num_destinations = 1;
    composite_delay_1_self->___act.token = __create_token(sizeof(int));
    composite_delay_1_self->___act.is_present = false;
    __tokens_with_ref_count[2].token
            = &composite_delay_1_self->___act.token;
    __tokens_with_ref_count[2].is_present
            = &composite_delay_1_self->___act.is_present;
    __tokens_with_ref_count[2].reset_is_present = true;
    //***** End initializing Composite.delay_1
    // ************* Instance Composite.delay_2 of class __GenDelay_197ef
    __gendelay_197ef_self_t* composite_delay_2_self = new___GenDelay_197ef();
    //***** Start initializing Composite.delay_2
    composite_delay_2_self->delay = MSEC(1);
    // Reaction 0 of Composite.delay_2 triggers 1 downstream reactions through port Composite.delay_2.out.
    composite_delay_2_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.delay_2, allocate an
    // array of trigger pointers for downstream reactions through port Composite.delay_2.out
    trigger_t** composite_delay_2_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_delay_2_self->___reaction_0.triggers[0] = composite_delay_2_0_0;
    composite_delay_2_self->___act.offset = MSEC(1);
    composite_delay_2_self->___act.period = 0;
    composite_delay_2_self->__out_num_destinations = 1;
    composite_delay_2_self->___act.token = __create_token(sizeof(int));
    composite_delay_2_self->___act.is_present = false;
    __tokens_with_ref_count[3].token
            = &composite_delay_2_self->___act.token;
    __tokens_with_ref_count[3].is_present
            = &composite_delay_2_self->___act.is_present;
    __tokens_with_ref_count[3].reset_is_present = true;
    //***** End initializing Composite.delay_2
    // ************* Instance Composite.delay_3 of class __GenDelay_197ef
    __gendelay_197ef_self_t* composite_delay_3_self = new___GenDelay_197ef();
    //***** Start initializing Composite.delay_3
    composite_delay_3_self->delay = MSEC(1);
    // Reaction 0 of Composite.delay_3 triggers 1 downstream reactions through port Composite.delay_3.out.
    composite_delay_3_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.delay_3, allocate an
    // array of trigger pointers for downstream reactions through port Composite.delay_3.out
    trigger_t** composite_delay_3_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_delay_3_self->___reaction_0.triggers[0] = composite_delay_3_0_0;
    composite_delay_3_self->___act.offset = MSEC(1);
    composite_delay_3_self->___act.period = 0;
    composite_delay_3_self->__out_num_destinations = 1;
    composite_delay_3_self->___act.token = __create_token(sizeof(int));
    composite_delay_3_self->___act.is_present = false;
    __tokens_with_ref_count[4].token
            = &composite_delay_3_self->___act.token;
    __tokens_with_ref_count[4].is_present
            = &composite_delay_3_self->___act.is_present;
    __tokens_with_ref_count[4].reset_is_present = true;
    //***** End initializing Composite.delay_3
    //***** End initializing Composite
    // Populate arrays of trigger pointers.
    // Point to destination port Composite.delay.inp's trigger struct.
    composite_arith_0_0[0] = &composite_delay_self->___inp;
    // Point to destination port Composite.delay.inp's trigger struct.
    composite_arith_1_0[0] = &composite_delay_self->___inp;
    // Point to destination port Composite.delay_1.inp's trigger struct.
    composite_relay_0_0[0] = &composite_delay_1_self->___inp;
    // Point to destination port Composite.delay_2.inp's trigger struct.
    composite_relay_0_0[1] = &composite_delay_2_self->___inp;
    // Point to destination port Composite.delay_3.inp's trigger struct.
    composite_relay_1_0[0] = &composite_delay_3_self->___inp;
    // Point to destination port Composite.arith.incr's trigger struct.
    composite_reset_0_0[0] = &composite_arith_self->___incr;
    // Point to destination port Composite.relay.r's trigger struct.
    composite_reset_0_1[0] = &composite_relay_self->___r;
    // Point to destination port Composite.delay_0.inp's trigger struct.
    composite_reset_1_0[0] = &composite_delay_0_self->___inp;
    // Point to destination port Composite.relay.in2's trigger struct.
    composite_delay_0_0[0] = &composite_relay_self->___in2;
    // Point to destination port Composite.out.in2's trigger struct.
    composite_delay_0_0_0[0] = &composite_out_self->___in2;
    // Point to destination port Composite.arith.dbl's trigger struct.
    composite_delay_1_0_0[0] = &composite_arith_self->___dbl;
    // Point to destination port Composite.reset.in's trigger struct.
    composite_delay_2_0_0[0] = &composite_reset_self->___in;
    // Point to destination port Composite.out.in's trigger struct.
    composite_delay_3_0_0[0] = &composite_out_self->___in;
    // doDeferredInitialize
    composite_arith_self->__dbl_is_present = &absent;
    composite_arith_self->__incr_is_present = &absent;
    composite_relay_self->__r_is_present = &absent;
    composite_relay_self->__in2_is_present = &absent;
    composite_reset_self->__in_is_present = &absent;
    composite_out_self->__in_is_present = &absent;
    composite_out_self->__in2_is_present = &absent;
    composite_delay_self->__inp_is_present = &absent;
    composite_delay_0_self->__inp_is_present = &absent;
    composite_delay_1_self->__inp_is_present = &absent;
    composite_delay_2_self->__inp_is_present = &absent;
    composite_delay_3_self->__inp_is_present = &absent;
    // Connect inputs and outputs for reactor Composite.
    // Connect Composite.reset.dbl to input port Composite.relay.r
    composite_relay_self->__r = &composite_reset_self->__dbl;
    composite_relay_self->__r_is_present = &composite_reset_self->__dbl_is_present;
    // Connect Composite.reset.incr to input port Composite.arith.incr
    composite_arith_self->__incr = &composite_reset_self->__incr;
    composite_arith_self->__incr_is_present = &composite_reset_self->__incr_is_present;
    // Connect Composite.arith.relay to input port Composite.delay.inp
    composite_delay_self->__inp = &composite_arith_self->__relay;
    composite_delay_self->__inp_is_present = &composite_arith_self->__relay_is_present;
    // Connect Composite.delay.out to input port Composite.relay.in2
    composite_relay_self->__in2 = &composite_delay_self->__out;
    composite_relay_self->__in2_is_present = &composite_delay_self->__out_is_present;
    // Connect Composite.reset.out to input port Composite.delay_0.inp
    composite_delay_0_self->__inp = &composite_reset_self->__out;
    composite_delay_0_self->__inp_is_present = &composite_reset_self->__out_is_present;
    // Connect Composite.delay_0.out to input port Composite.out.in2
    composite_out_self->__in2 = &composite_delay_0_self->__out;
    composite_out_self->__in2_is_present = &composite_delay_0_self->__out_is_present;
    // Connect Composite.relay.out to input port Composite.delay_1.inp
    composite_delay_1_self->__inp = &composite_relay_self->__out;
    composite_delay_1_self->__inp_is_present = &composite_relay_self->__out_is_present;
    // Connect Composite.relay.out to input port Composite.delay_2.inp
    composite_delay_2_self->__inp = &composite_relay_self->__out;
    composite_delay_2_self->__inp_is_present = &composite_relay_self->__out_is_present;
    // Connect Composite.delay_1.out to input port Composite.arith.dbl
    composite_arith_self->__dbl = &composite_delay_1_self->__out;
    composite_arith_self->__dbl_is_present = &composite_delay_1_self->__out_is_present;
    // Connect Composite.delay_2.out to input port Composite.reset.in
    composite_reset_self->__in = &composite_delay_2_self->__out;
    composite_reset_self->__in_is_present = &composite_delay_2_self->__out_is_present;
    // Connect Composite.relay.out2 to input port Composite.delay_3.inp
    composite_delay_3_self->__inp = &composite_relay_self->__out2;
    composite_delay_3_self->__inp_is_present = &composite_relay_self->__out2_is_present;
    // Connect Composite.delay_3.out to input port Composite.out.in
    composite_out_self->__in = &composite_delay_3_self->__out;
    composite_out_self->__in_is_present = &composite_delay_3_self->__out_is_present;
    // Connect inputs and outputs for reactor Composite.arith.
    // END Connect inputs and outputs for reactor Composite.arith.
    // Connect inputs and outputs for reactor Composite.relay.
    // END Connect inputs and outputs for reactor Composite.relay.
    // Connect inputs and outputs for reactor Composite.reset.
    // END Connect inputs and outputs for reactor Composite.reset.
    // Connect inputs and outputs for reactor Composite.out.
    // END Connect inputs and outputs for reactor Composite.out.
    // Connect inputs and outputs for reactor Composite.delay.
    // END Connect inputs and outputs for reactor Composite.delay.
    // Connect inputs and outputs for reactor Composite.delay_0.
    // END Connect inputs and outputs for reactor Composite.delay_0.
    // Connect inputs and outputs for reactor Composite.delay_1.
    // END Connect inputs and outputs for reactor Composite.delay_1.
    // Connect inputs and outputs for reactor Composite.delay_2.
    // END Connect inputs and outputs for reactor Composite.delay_2.
    // Connect inputs and outputs for reactor Composite.delay_3.
    // END Connect inputs and outputs for reactor Composite.delay_3.
    // END Connect inputs and outputs for reactor Composite.
    // Add port Composite.arith.relay to array of _is_present fields.
    __is_present_fields[0] = &composite_arith_self->__relay_is_present;
    // Add port Composite.relay.out to array of _is_present fields.
    __is_present_fields[1] = &composite_relay_self->__out_is_present;
    // Add port Composite.relay.out2 to array of _is_present fields.
    __is_present_fields[2] = &composite_relay_self->__out2_is_present;
    // Add port Composite.reset.dbl to array of _is_present fields.
    __is_present_fields[3] = &composite_reset_self->__dbl_is_present;
    // Add port Composite.reset.incr to array of _is_present fields.
    __is_present_fields[4] = &composite_reset_self->__incr_is_present;
    // Add port Composite.reset.out to array of _is_present fields.
    __is_present_fields[5] = &composite_reset_self->__out_is_present;
    // Add port Composite.delay.out to array of _is_present fields.
    __is_present_fields[6] = &composite_delay_self->__out_is_present;
    // Add port Composite.delay_0.out to array of _is_present fields.
    __is_present_fields[7] = &composite_delay_0_self->__out_is_present;
    // Add port Composite.delay_1.out to array of _is_present fields.
    __is_present_fields[8] = &composite_delay_1_self->__out_is_present;
    // Add port Composite.delay_2.out to array of _is_present fields.
    __is_present_fields[9] = &composite_delay_2_self->__out_is_present;
    // Add port Composite.delay_3.out to array of _is_present fields.
    __is_present_fields[10] = &composite_delay_3_self->__out_is_present;
    composite_arith_self->___reaction_0.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_arith_self->___reaction_0.index = 0x7fffffffffff0001LL;
    composite_arith_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_arith_self->___reaction_1.index = 0x7fffffffffff0002LL;
    composite_relay_self->___reaction_0.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_relay_self->___reaction_0.index = 0x7fffffffffff0001LL;
    composite_relay_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_relay_self->___reaction_1.index = 0x7fffffffffff0002LL;
    composite_reset_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_reset_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_reset_self->___reaction_1.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_reset_self->___reaction_1.index = 0x7fffffffffff0001LL;
    composite_out_self->___reaction_0.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_out_self->___reaction_0.index = 0x7fffffffffff0001LL;
    composite_out_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_out_self->___reaction_1.index = 0x7fffffffffff0002LL;
    composite_delay_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_delay_self->___reaction_1.chain_id = 1;
    // index is the OR of level 3 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_self->___reaction_1.index = 0x7fffffffffff0003LL;
    composite_delay_0_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_0_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_delay_0_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_0_self->___reaction_1.index = 0x7fffffffffff0002LL;
    composite_delay_1_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_1_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_delay_1_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_1_self->___reaction_1.index = 0x7fffffffffff0002LL;
    composite_delay_2_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_2_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_delay_2_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_2_self->___reaction_1.index = 0x7fffffffffff0002LL;
    composite_delay_3_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_3_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_delay_3_self->___reaction_1.chain_id = 1;
    // index is the OR of level 3 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_3_self->___reaction_1.index = 0x7fffffffffff0003LL;
}
void __start_timers() {
    
    for (int i = 0; i < __timer_triggers_size; i++) {
        __schedule(__timer_triggers[i], 0LL, NULL);
    }
}
void logical_time_complete(instant_t time) {
}
instant_t next_event_time(instant_t time) {
    return time;
}
bool __wrapup() {
    __start_time_step();   // To free memory allocated for actions.
    return false;
}
void __termination() {}
