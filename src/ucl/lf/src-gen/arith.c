// Code generated by the Lingua Franca compiler from file:
// /Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf
#include "pqueue.c"
#define NUMBER_OF_FEDERATES 1
#include "reactor.c"
// =============== START reactor class X
typedef struct {
    #line 7 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int s;
    #line 5 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int* __dbl;
    #line 5 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    bool* __dbl_is_present;
    #line 6 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int* __incr;
    #line 6 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    bool* __incr_is_present;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[0];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[0];
    int __reaction_0_triggered_sizes[0];
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    reaction_t ___reaction_1;
    bool* __reaction_1_outputs_are_present[0];
    int __reaction_1_num_outputs;
    trigger_t** __reaction_1_triggers[0];
    int __reaction_1_triggered_sizes[0];
    #line 5 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    trigger_t ___dbl;
    #line 5 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    reaction_t* ___dbl_reactions[1];
    #line 6 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    trigger_t ___incr;
    #line 6 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    reaction_t* ___incr_reactions[1];
} x_self_t;
void xreaction_function_0(void* instance_args) {
    x_self_t* self = (x_self_t*)instance_args;
    bool dbl_is_present = *(self->__dbl_is_present);
    int dbl;
    if (dbl_is_present) {
                           dbl = *(self->__dbl);
    }
    #line 10 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->s *= 2;
    printf("%d\n", self->s);
        
}
void xreaction_function_1(void* instance_args) {
    x_self_t* self = (x_self_t*)instance_args;
    bool incr_is_present = *(self->__incr_is_present);
    int incr;
    if (incr_is_present) {
                           incr = *(self->__incr);
    }
    #line 15 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->s += incr;
    printf("%d\n", self->s);
        
}
x_self_t* new_X() {
    x_self_t* self = (x_self_t*)calloc(1, sizeof(x_self_t));
    self->__reaction_0_num_outputs = 0;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.function = xreaction_function_0;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.self = self;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.num_outputs = 0;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    #line 9 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    self->__reaction_1_num_outputs = 0;
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_1.function = xreaction_function_1;
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_1.self = self;
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_1.num_outputs = 0;
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_1.output_produced = self->__reaction_1_outputs_are_present;
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_1.triggered_sizes = self->__reaction_1_triggered_sizes;
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_1.triggers = self->__reaction_1_triggers;
    #line 14 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 5 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___dbl.scheduled = NEVER;
    #line 5 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___dbl_reactions[0] = &self->___reaction_0;
    self->___dbl.reactions = &self->___dbl_reactions[0];
    self->___dbl.number_of_reactions = 1;
    self->___dbl.element_size = sizeof(int);
    #line 6 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___incr.scheduled = NEVER;
    #line 6 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___incr_reactions[0] = &self->___reaction_1;
    self->___incr.reactions = &self->___incr_reactions[0];
    self->___incr.number_of_reactions = 1;
    self->___incr.element_size = sizeof(int);
    return self;
}
// =============== END reactor class X

// =============== START reactor class Relay
typedef struct {
    #line 21 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int* __r;
    #line 21 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    bool* __r_is_present;
    #line 22 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int __out;
    #line 22 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    bool __out_is_present;
    #line 22 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int __out_num_destinations;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[1];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[1];
    int __reaction_0_triggered_sizes[1];
    #line 21 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    trigger_t ___r;
    #line 21 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    reaction_t* ___r_reactions[1];
} relay_self_t;
void relayreaction_function_0(void* instance_args) {
    relay_self_t* self = (relay_self_t*)instance_args;
    bool r_is_present = *(self->__r_is_present);
    int r;
    if (r_is_present) {
                           r = *(self->__r);
    }
    int* out = &(self->__out);
    bool out_is_present = self->__out_is_present;
    #line 24 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    set(out, r);
        
}
relay_self_t* new_Relay() {
    relay_self_t* self = (relay_self_t*)calloc(1, sizeof(relay_self_t));
    self->__reaction_0_outputs_are_present[0] = &self->__out_is_present;
    self->__reaction_0_num_outputs = 1;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.function = relayreaction_function_0;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.self = self;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.num_outputs = 1;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    #line 23 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    #line 21 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___r.scheduled = NEVER;
    #line 21 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___r_reactions[0] = &self->___reaction_0;
    self->___r.reactions = &self->___r_reactions[0];
    self->___r.number_of_reactions = 1;
    self->___r.element_size = sizeof(int);
    return self;
}
// =============== END reactor class Relay

// =============== START reactor class Y
typedef struct {
    #line 29 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int __dbl;
    #line 29 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    bool __dbl_is_present;
    #line 29 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int __dbl_num_destinations;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int __incr;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    bool __incr_is_present;
    #line 30 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    int __incr_num_destinations;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[2];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[2];
    int __reaction_0_triggered_sizes[2];
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
} y_self_t;
void yreaction_function_0(void* instance_args) {
    y_self_t* self = (y_self_t*)instance_args;
    int* dbl = &(self->__dbl);
    bool dbl_is_present = self->__dbl_is_present;
    int* incr = &(self->__incr);
    bool incr_is_present = self->__incr_is_present;
    #line 32 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    set(incr, 1);
    set(dbl, 1);
        
}
y_self_t* new_Y() {
    y_self_t* self = (y_self_t*)calloc(1, sizeof(y_self_t));
    self->__reaction_0_outputs_are_present[0] = &self->__dbl_is_present;
    self->__reaction_0_outputs_are_present[1] = &self->__incr_is_present;
    self->__reaction_0_num_outputs = 2;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.function = yreaction_function_0;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.self = self;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.num_outputs = 2;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    #line 31 "file:/Users/shaokai/Documents/projects/lingua-franca/lf-fv/uclid/lf/arith.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___startup.scheduled = NEVER;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = true;
    return self;
}
// =============== END reactor class Y

// =============== START reactor class __GenDelay_197ef
typedef struct {
    interval_t delay;
    int* __inp;
    bool* __inp_is_present;
    int __out;
    bool __out_is_present;
    int __out_num_destinations;
    reaction_t ___reaction_0;
    bool* __reaction_0_outputs_are_present[1];
    int __reaction_0_num_outputs;
    trigger_t** __reaction_0_triggers[1];
    int __reaction_0_triggered_sizes[1];
    reaction_t ___reaction_1;
    bool* __reaction_1_outputs_are_present[0];
    int __reaction_1_num_outputs;
    trigger_t** __reaction_1_triggers[0];
    int __reaction_1_triggered_sizes[0];
    trigger_t ___act;
    reaction_t* ___act_reactions[1];
    trigger_t ___inp;
    reaction_t* ___inp_reactions[1];
} __gendelay_197ef_self_t;
void __gendelay_197efreaction_function_0(void* instance_args) {
    __gendelay_197ef_self_t* self = (__gendelay_197ef_self_t*)instance_args;
    bool act_is_present = self->___act.is_present;
    bool act_has_value = ((self->___act.token) != NULL && (self->___act.token)->value != NULL);
    token_t* act_token = (self->___act.token);
    int act_value;
    if (act_has_value) {
        act_value = *((int*)(self->___act.token)->value);
    }
    int* out = &(self->__out);
    bool out_is_present = self->__out_is_present;
    set(out, act_value);
}
void __gendelay_197efreaction_function_1(void* instance_args) {
    __gendelay_197ef_self_t* self = (__gendelay_197ef_self_t*)instance_args;
    bool inp_is_present = *(self->__inp_is_present);
    int inp;
    if (inp_is_present) {
                           inp = *(self->__inp);
    }
    trigger_t* act = &self->___act;
    schedule_copy(act, 0, &inp, 1);  // Length is 1.
}
__gendelay_197ef_self_t* new___GenDelay_197ef() {
    __gendelay_197ef_self_t* self = (__gendelay_197ef_self_t*)calloc(1, sizeof(__gendelay_197ef_self_t));
    self->__reaction_0_outputs_are_present[0] = &self->__out_is_present;
    self->__reaction_0_num_outputs = 1;
    self->___reaction_0.function = __gendelay_197efreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.num_outputs = 1;
    self->___reaction_0.output_produced = self->__reaction_0_outputs_are_present;
    self->___reaction_0.triggered_sizes = self->__reaction_0_triggered_sizes;
    self->___reaction_0.triggers = self->__reaction_0_triggers;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->__reaction_1_num_outputs = 0;
    self->___reaction_1.function = __gendelay_197efreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.num_outputs = 0;
    self->___reaction_1.output_produced = self->__reaction_1_outputs_are_present;
    self->___reaction_1.triggered_sizes = self->__reaction_1_triggered_sizes;
    self->___reaction_1.triggers = self->__reaction_1_triggers;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___act.scheduled = NEVER;
    self->___act_reactions[0] = &self->___reaction_0;
    self->___act.reactions = &self->___act_reactions[0];
    self->___act.number_of_reactions = 1;
    self->___act.is_physical = false;
    self->___act.drop = false;
    self->___act.element_size = sizeof(int);
    self->___inp.scheduled = NEVER;
    self->___inp_reactions[0] = &self->___reaction_1;
    self->___inp.reactions = &self->___inp_reactions[0];
    self->___inp.number_of_reactions = 1;
    self->___inp.element_size = sizeof(int);
    return self;
}
// =============== END reactor class __GenDelay_197ef

// =============== START reactor class Composite
typedef struct {
    bool hasContents;
} composite_self_t;
composite_self_t* new_Composite() {
    composite_self_t* self = (composite_self_t*)calloc(1, sizeof(composite_self_t));
    return self;
}
// =============== END reactor class Composite

void __set_default_command_line_options() {
}
// Array of pointers to timer triggers to start the timers in __start_timers().
trigger_t* __timer_triggers[1];
int __timer_triggers_size = 1;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 1;
    __tokens_with_ref_count = (token_present_t*)malloc(1 * sizeof(token_present_t));
    // Create the array that will contain pointers to _is_present fields to reset on each step.
    __is_present_fields_size = 4;
    __is_present_fields = (bool**)malloc(4 * sizeof(bool*));
    // ************* Instance Composite of class Composite
    composite_self_t* composite_self = new_Composite();
    //***** Start initializing Composite
    // ************* Instance Composite.x of class X
    x_self_t* composite_x_self = new_X();
    //***** Start initializing Composite.x
    static int composite_x_initial_s = 1;
    composite_x_self->s = composite_x_initial_s;
    //***** End initializing Composite.x
    // ************* Instance Composite.r of class Relay
    relay_self_t* composite_r_self = new_Relay();
    //***** Start initializing Composite.r
    // Reaction 0 of Composite.r triggers 1 downstream reactions through port Composite.r.out.
    composite_r_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.r, allocate an
    // array of trigger pointers for downstream reactions through port Composite.r.out
    trigger_t** composite_r_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_r_self->___reaction_0.triggers[0] = composite_r_0_0;
    composite_r_self->__out_num_destinations = 1;
    //***** End initializing Composite.r
    // ************* Instance Composite.y of class Y
    y_self_t* composite_y_self = new_Y();
    //***** Start initializing Composite.y
    // Reaction 0 of Composite.y triggers 1 downstream reactions through port Composite.y.dbl.
    composite_y_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.y, allocate an
    // array of trigger pointers for downstream reactions through port Composite.y.dbl
    trigger_t** composite_y_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_y_self->___reaction_0.triggers[0] = composite_y_0_0;
    // Reaction 0 of Composite.y triggers 1 downstream reactions through port Composite.y.incr.
    composite_y_self->___reaction_0.triggered_sizes[1] = 1;
    // For reaction 0 of Composite.y, allocate an
    // array of trigger pointers for downstream reactions through port Composite.y.incr
    trigger_t** composite_y_0_1 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_y_self->___reaction_0.triggers[1] = composite_y_0_1;
    composite_y_self->___startup.offset = 0;
    composite_y_self->___startup.period = 0;
    __timer_triggers[0] = &composite_y_self->___startup;
    composite_y_self->__dbl_num_destinations = 1;
    composite_y_self->__incr_num_destinations = 1;
    //***** End initializing Composite.y
    // ************* Instance Composite.delay of class __GenDelay_197ef
    __gendelay_197ef_self_t* composite_delay_self = new___GenDelay_197ef();
    //***** Start initializing Composite.delay
    composite_delay_self->delay = MSEC(1);
    // Reaction 0 of Composite.delay triggers 1 downstream reactions through port Composite.delay.out.
    composite_delay_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of Composite.delay, allocate an
    // array of trigger pointers for downstream reactions through port Composite.delay.out
    trigger_t** composite_delay_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    composite_delay_self->___reaction_0.triggers[0] = composite_delay_0_0;
    composite_delay_self->___act.offset = MSEC(1);
    composite_delay_self->___act.period = 0;
    composite_delay_self->__out_num_destinations = 1;
    composite_delay_self->___act.token = __create_token(sizeof(int));
    composite_delay_self->___act.is_present = false;
    __tokens_with_ref_count[0].token
            = &composite_delay_self->___act.token;
    __tokens_with_ref_count[0].is_present
            = &composite_delay_self->___act.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    //***** End initializing Composite.delay
    //***** End initializing Composite
    // Populate arrays of trigger pointers.
    // Point to destination port Composite.delay.inp's trigger struct.
    composite_r_0_0[0] = &composite_delay_self->___inp;
    // Point to destination port Composite.r.r's trigger struct.
    composite_y_0_0[0] = &composite_r_self->___r;
    // Point to destination port Composite.x.incr's trigger struct.
    composite_y_0_1[0] = &composite_x_self->___incr;
    // Point to destination port Composite.x.dbl's trigger struct.
    composite_delay_0_0[0] = &composite_x_self->___dbl;
    // doDeferredInitialize
    composite_x_self->__dbl_is_present = &absent;
    composite_x_self->__incr_is_present = &absent;
    composite_r_self->__r_is_present = &absent;
    composite_delay_self->__inp_is_present = &absent;
    // Connect inputs and outputs for reactor Composite.
    // Connect Composite.y.dbl to input port Composite.r.r
    composite_r_self->__r = &composite_y_self->__dbl;
    composite_r_self->__r_is_present = &composite_y_self->__dbl_is_present;
    // Connect Composite.y.incr to input port Composite.x.incr
    composite_x_self->__incr = &composite_y_self->__incr;
    composite_x_self->__incr_is_present = &composite_y_self->__incr_is_present;
    // Connect Composite.r.out to input port Composite.delay.inp
    composite_delay_self->__inp = &composite_r_self->__out;
    composite_delay_self->__inp_is_present = &composite_r_self->__out_is_present;
    // Connect Composite.delay.out to input port Composite.x.dbl
    composite_x_self->__dbl = &composite_delay_self->__out;
    composite_x_self->__dbl_is_present = &composite_delay_self->__out_is_present;
    // Connect inputs and outputs for reactor Composite.x.
    // END Connect inputs and outputs for reactor Composite.x.
    // Connect inputs and outputs for reactor Composite.r.
    // END Connect inputs and outputs for reactor Composite.r.
    // Connect inputs and outputs for reactor Composite.y.
    // END Connect inputs and outputs for reactor Composite.y.
    // Connect inputs and outputs for reactor Composite.delay.
    // END Connect inputs and outputs for reactor Composite.delay.
    // END Connect inputs and outputs for reactor Composite.
    // Add port Composite.r.out to array of _is_present fields.
    __is_present_fields[0] = &composite_r_self->__out_is_present;
    // Add port Composite.y.dbl to array of _is_present fields.
    __is_present_fields[1] = &composite_y_self->__dbl_is_present;
    // Add port Composite.y.incr to array of _is_present fields.
    __is_present_fields[2] = &composite_y_self->__incr_is_present;
    // Add port Composite.delay.out to array of _is_present fields.
    __is_present_fields[3] = &composite_delay_self->__out_is_present;
    composite_x_self->___reaction_0.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_x_self->___reaction_0.index = 0x7fffffffffff0001LL;
    composite_x_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_x_self->___reaction_1.index = 0x7fffffffffff0002LL;
    composite_r_self->___reaction_0.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_r_self->___reaction_0.index = 0x7fffffffffff0001LL;
    composite_y_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_y_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_delay_self->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_self->___reaction_0.index = 0x7fffffffffff0000LL;
    composite_delay_self->___reaction_1.chain_id = 1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    composite_delay_self->___reaction_1.index = 0x7fffffffffff0002LL;
}
void __start_timers() {
    
    for (int i = 0; i < __timer_triggers_size; i++) {
        __schedule(__timer_triggers[i], 0LL, NULL);
    }
}
void logical_time_complete(instant_t time) {
}
instant_t next_event_time(instant_t time) {
    return time;
}
bool __wrapup() {
    __start_time_step();   // To free memory allocated for actions.
    return false;
}
void __termination() {}
