/**
 * A priority queue implementation for reactors.
 *
 * In this implementation, events with the lowest tag
 * are popped together in the _out array along with
 * _out_tail, indicating the array length. The user
 * should provide both the input array and the length. 
 */

/**
 * A helper module for common types and constants
 */
module Common {
    // FILE_SPECIFIC
    type reactor_id_t = enum { A, B, NULL };
    type trigger_id_t = enum { A_OUT, B_IN, N_NULL };
    type token_t      = integer; // To support "anytype"

    // COMMON
    type instant_t    = integer;
    type is_present_t = boolean;

    /**
     * Use tuple instead of record for easy instantiation,
     * the event_t tuple is defined as [from_reactor_id,
     * to_reactor_id, time_of_release, trigger_id, token]
     *
     * Note: if type overload is enabled, the token_t field
     * can be reduced to 1 field. Otherwise, multiple token_t
     * fields are needed depending on the LF program.
     */
    type event_t = {
                     instant_t,     // Tag
                     reactor_id_t,  // From
                     reactor_id_t,  // To
                     trigger_id_t,  // Trigger
                     token_t,       // Token
                     is_present_t   // Is_present
                   };

    /*
    // TODO: replace concrete __null__ instantiation with abstract const.
    const null_event : event_t;
    axiom (forall (e : event_t) :: null_event._1 > e._1);
    */
}

module PQueue {
    type *   = Common.*;
    const *  = Common.*;

    type op_t    = enum { PUSH, POP };
    type index_t = integer;
    type queue_t = [index_t]event_t;

    /**
     * Calling it the largest possible index value
     * instead of size because range(a, b) includes b
     * and it would be more natural to have
     * range(0, MAX_IDX).
     * It is currently not possible to have
     * range(0, SIZE - 1), where SIZE = MAX_IDX + 1.
     */
    const MAX_IDX : integer = 4;

    // Public vars
    var contents : queue_t;
    /**
     * Points to the last value in array.
     * count = tail + 1.
     * If tail = -1, queue is empty.
     */
    var tail : index_t; 

    // Helper vars
    var __null__    : event_t;          // NULL event definition
	var __min_t__   : integer;          // To store the min tag in popQ()
    var __ret__     : [index_t]event_t; // The private ret arr in popQ()
    var __ret_tail__: index_t;          // The tail index of __ret__
    var __new_arr__ : [index_t]event_t; // The leftover arr in popQ()
    var __tail_prev__ : index_t;       // The tail value before exec.

    // Inputs
    input op         : op_t;
    input _in        : [index_t]event_t;
    input _in_tail   : index_t; // Index pointing to the last elem of _in

    // Outputs
    output _out      : [index_t]event_t;
    output _out_tail : index_t;

	init {
		tail            = -1;
        __tail_prev__   = -1;
		__min_t__        = 65535;
        // Tag set to 2^16 - 1.
        __null__         = { 65535, NULL, NULL, N_NULL, -1, false };
        __ret_tail__ = -1;

        // FIXME: UCLID does not allow the use of const MAX_IDX here
        for i in range(0, 4) {
            contents[i]  = __null__;
        }
	}

    /**
     * Push an array of value into the contents arr
     * by appending the values at the end, assuming
     * contents do not include null events.
     *
     * An index of -1 denotes empty array.
     * The contents array can be empty, but the
     * _in array cannot.
     */
	procedure pushQ(
                    __in__       : [index_t]event_t,
                    __in_tail__  : index_t
                )
        modifies contents, tail, __tail_prev__;

        requires (op == PUSH);
        // requires (__null__ == { 65535, NULL, NULL, N_NULL, -1, false });
        requires (__in_tail__ >= 0 && __in_tail__ < (MAX_IDX - tail));
        requires (tail >= -1 && tail <= MAX_IDX);
        requires (forall (i : integer) :: (i >= 0 && i <= __in_tail__)
                    ==> __in__[i] != __null__);
        requires (forall (i : integer) :: 
                    (i >= 0 && i <= tail) ==> contents[i] != __null__);
        ensures (tail == __tail_prev__ + (__in_tail__ + 1));
        ensures (forall (i : integer) :: (i >= 0 && i <= tail)
                    ==> contents[i] != __null__);
	{
        __tail_prev__ = tail;
        for (i : integer) in range(0, MAX_IDX) {
            if (i <= __in_tail__) {
                tail = tail + 1;
                contents = contents[tail -> __in__[i]];
            }
        }
	}

    /**
     * Pop the events with the minimum tag.
     * This operation is organized into 3 steps:
     * 1. Find the minimum tag.
     * 2. Put elements with the min tag into a new arr.
     * 3. Create a new contents array without the popped vals.
     */
    procedure popQ()
        returns (
            _out         : [index_t]event_t,
            _out_tail    : integer
        )
        modifies __min_t__, __ret__, __ret_tail__,
                __new_arr__, __tail_prev__, tail,
                contents;
        
        requires (op == POP);
        requires (__null__ == { 65535, NULL, NULL, N_NULL, -1, false });
        requires (tail > -1 && tail <= MAX_IDX);
        // Removal of the nested parantheses creates a syntax error
        ensures (tail == __tail_prev__ - (_out_tail + 1));
        ensures (forall (i : integer, j : integer) :: 
                    (i >= 0 && i <= tail && j >= 0 && j <= _out_tail) 
                    ==> contents[i]._1 >= _out[j]._1);
    {
        // Init variables
        __min_t__ = 65535;
        __ret_tail__ = -1;
        __tail_prev__ = tail;
        for (i : integer) in range(0, MAX_IDX) {
            __ret__[i] = __null__;
            __new_arr__[i] = __null__;
        }

        // Find the min tag
        for (i : integer) in range(0, MAX_IDX) {
            if (i <= tail && contents[i]._1 < __min_t__) {
                __min_t__ = contents[i]._1;
            }
        }

        // Add popped events to ret array
        for (i : integer) in range(0, MAX_IDX) {
            if (__min_t__ == contents[i]._1) {
                tail = tail - 1;
                __ret_tail__ = __ret_tail__ + 1;
                __ret__ = __ret__[__ret_tail__ -> contents[i]];
            }
        }

        // Create a leftover array
        for (i : integer) in range(0, MAX_IDX) {
            if (i <= tail && contents[i]._1 > __min_t__) {
                __new_arr__ = __new_arr__[i -> contents[i]];
            }
        }

        contents     = __new_arr__;
        _out         = __ret__;
        _out_tail    = __ret_tail__;
    }

    next {
        case
            (op == PUSH) : {
                call () = pushQ(_in, _in_tail);
            }
            (op == POP) : {
                call (_out', _out_tail') = popQ();
            }
        esac;
    }

    control {
        vPush   = verify(pushQ);
        vPop    = verify(popQ);
        check;
        print_results;
        vPush.print_cex;
        vPop.print_cex;
    }
}

module main {
    
    type * = PQueue.*;

    var op : op_t;
    var _in : [index_t]event_t;
    var _in_tail : integer;
    var _out : [index_t]event_t;
    var _out_tail : integer;
    
    var __null__ : event_t;
    var __contents__ : [index_t]event_t;

    instance event_q : PQueue(op : (op), _in : (_in),
                                _in_tail : (_in_tail),
                                _out : (_out),
                                _out_tail : (_out_tail));

    init {
        /*
        // FIXME: figure out if instance init blocks
        // are executed at instantiation.

        // event_q init
		event_q.count            = 0;
        event_q.__count_prev__   = 0;
        event_q.remaining        = 4;
		event_q.__min_t__        = 0;
        // Tag set to 2^16 - 1.
        __null__         = { 65535, NULL, NULL, N_NULL, -1, false };
        event_q.__null__         = { 65535, NULL, NULL, N_NULL, -1, false };

        // FIXME: UCLID does not allow the use of const MAX_IDX here
        for i in range(0, 4) {
           __contents__[i]  = __null__;
        }
        event_q.contents = __contents__;
        */

        /*
        __contents__[0] = { 65535, NULL, NULL, N_NULL, -1, false };
        __contents__[1] = { 1, NULL, NULL, N_NULL, -1, false };
        __contents__[2] = { 2, NULL, NULL, N_NULL, -1, false };
        */

        // input init
        op = PUSH;
        for (i : integer) in range(0, 2) {
            _in[i] = { 2, A, B, A_OUT, 1, true };
        }
        _in_tail = 2;
    }

    next {
        next(event_q);
    }

    control {
        v = unroll(2);
        check;
        print_results;
        v.print_cex;
    }
}
