/**
 * A new formulation of the reactor semantics.
 */

/**
 * A helper module for common types and constants
 */
module Common {
    // FILE_SPECIFIC
    type reactor_id_t = enum { A, B, NULL };
    type trigger_id_t = enum { A_STARTUP, B_STARTUP, B_IN, N_NULL };
    type token_t      = integer; // To support "anytype"

    // COMMON
    type instant_t    = integer;
    type is_present_t = boolean;

    /**
     * Use tuple instead of record for easy instantiation,
     * the event_t tuple is defined as [from_reactor_id,
     * to_reactor_id, time_of_release, trigger_id, token]
     *
     * Note: if type overload is enabled, the token_t field
     * can be reduced to 1 field. Otherwise, multiple token_t
     * fields are needed depending on the LF program.
     */
    // Note: instant_t and is_present, redundant?
    type event_t = {
                     instant_t,     // Tag
                     reactor_id_t,  // From
                     reactor_id_t,  // To
                     trigger_id_t,  // Trigger
                     token_t,       // Token
                     is_present_t   // Is_present
                   };

    /*
    // TODO: replace concrete __null__ instantiation with abstract const.
    const null_event : event_t;
    axiom (forall (e : event_t) :: null_event._1 > e._1);
    */
}

module EventQ
{
    type * = Common.*;

    type op_t = enum { PUSH, POP };
    type index_t = integer;
    type count_t = integer;
    type data_t = event_t;
    type queue_t = [index_t]data_t;
    
    const END : integer = 4; // The size of pqueue is 5.
    var NULL_EVENT : data_t;

    input op : op_t;
    input data : data_t;

    output out : data_t; // Output from popQ()

    var contents : queue_t;
    var count : integer; 

    var __done__ : boolean;
    var __min__ : data_t;
    var __min_idx__ : index_t;

    define in_queue(q : [index_t]data_t, v : data_t) : boolean =
        (exists (i : index_t) ::
            (i >= 0 && i <= END) && q[i] == v);

    procedure pushQ()
        returns (
            contentsP : queue_t,
            countP : integer
        )
        modifies __done__;
        // requires ( op == POP ); // Useful for printing execution traces
        // requires ( data == { -2, NULL, NULL, N_NULL, -1, false } ); // Useful for printout purposes
        /*
        requires ( op == PUSH ); // OP must be PUSH
        requires ( count >= 0 && count < END + 1 ); // PQueue cannot be full. 
        // The meaning of not being full.
        requires (exists (i : integer) ::
                    (i >= 0 && i < count) && contents[i] == NULL_EVENT);
        // Require the array does not contain the element
        requires ( !in_queue(contents, data) );
        // When these two post-conditions are disabled,
        // the queue output behaves normally.
        ensures ( countP == count + 1 );
        ensures ( in_queue(contentsP, data) );
        */
    {
        __done__ = false; // To prevent repetitive updates.
        // contentsP = contents; // Can only assign to return once.
        for (i : integer) in range(0, END) {
            if (contents[i] == NULL_EVENT && 
                !__done__ &&
                data != NULL_EVENT) // important to make sure data is not null 
            {
                contentsP = contents[i -> data];
                countP = count + 1;
                __done__ = true;
            }
        }
        // Need to explicitly specify the values in the next state.
        if (!__done__) {
            contentsP = contents;
            countP = count;
        }
    }

    procedure popQ()
        returns (
            contentsP : [index_t]data_t,
            countP : integer,
            out : data_t
        )
        modifies __min__, __min_idx__;
        // requires ( op == PUSH ); // Useful for printing execution traces
        /*
        requires (op == POP);
        // Must not be empty
        requires ( exists (i : integer) ::
                    (i >= 0 && i <= END) &&
                    contents[i]._1 >= 0 );
        ensures (countP == count - 1);
        */
    {
        __min__ = contents[0];
        __min_idx__ = 0; 

        // Find the minimum
        for (i : integer) in range(0, END) {
            if (contents[i] != NULL_EVENT) {
                if (__min__ == NULL_EVENT) {
                    __min__ = contents[i];
                    __min_idx__ = i;
                }
                else {
                    if (contents[i]._1 < __min__._1) {
                        __min__ = contents[i];
                        __min_idx__ = i;
                    }
                }
            }
        }

        out = __min__;
        contentsP = contents[__min_idx__ -> NULL_EVENT];
        if (out == NULL_EVENT) {
            countP = count;
        }
        else {
            countP = count - 1;
        }
    }

    init {

        /*
        contents[0] = { 2, A, B, A_OUT, 1, true };
        contents[1] = { 1, A, B, A_OUT, 5, true };
        for (i : integer) in range(2, END) {
            contents[i] = NULL_EVENT;
        }
        */

        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        __done__ = false;
        __min__ = NULL_EVENT;

        /********************
         * A useful test case
         *******************/

        count = 0;

        // Step 1
        // count = 1;
        // contents[0] = { 0, A, A, A_STARTUP, 0, true };

        // Make the rest NULL_EVENT
        for (i : integer) in range(0, END) {
            contents[i] = NULL_EVENT;
        }
    }

    next {
        case
            (op == PUSH) : {
                call (contents', count') = pushQ();
            }
            (op == POP) : {
                call (contents', count', out') = popQ();
            }
        esac;
    }

    control {
        vPush = verify(pushQ);
        vPop = verify(popQ);
        check;
        print_results;
        vPush.print_cex();
        vPop.print_cex();
    }
}

module ReactionQ
{
    type * = Common.*;

    type op_t = enum { PUSH, POP };
    type index_t = integer;
    type count_t = integer;
    type data_t = event_t;
    type queue_t = [index_t]data_t;
    
    const END : integer = 4; // The size of pqueue is 5.
    var NULL_EVENT : data_t;

    input op : op_t;
    input data : data_t;

    output out : data_t; // Output from popQ()

    var priority : [trigger_id_t]integer; 
    var contents : queue_t;
    var count : integer; 

    var __done__ : boolean;
    var __min__ : data_t;
    var __min_idx__ : index_t;

    define in_queue(q : [index_t]data_t, v : data_t) : boolean =
        (exists (i : index_t) ::
            (i >= 0 && i <= END) && q[i] == v);

    procedure pushQ()
        returns (
            contentsP : queue_t,
            countP : integer
        )
        modifies __done__;
        // requires ( op == POP ); // Useful for printing execution traces
        // requires ( data == { -2, NULL, NULL, N_NULL, -1, false } ); // Useful for printout purposes
        /*
        requires ( op == PUSH ); // OP must be PUSH
        requires ( count >= 0 && count < END + 1 ); // PQueue cannot be full. 
        // The meaning of not being full.
        requires (exists (i : integer) ::
                    (i >= 0 && i < count) && contents[i] == NULL_EVENT);
        // Require the array does not contain the element
        requires ( !in_queue(contents, data) );
        // When these two post-conditions are disabled,
        // the queue output behaves normally.
        ensures ( countP == count + 1 );
        ensures ( in_queue(contentsP, data) );
        */
    {
        __done__ = false; // To prevent repetitive updates.
        // contentsP = contents; // Can only assign to return once.
        for (i : integer) in range(0, END) {
            if (contents[i] == NULL_EVENT && 
                !__done__ &&
                data != NULL_EVENT) // important to make sure data is not null 
            {
                contentsP = contents[i -> data];
                countP = count + 1;
                __done__ = true;
            }
        }
        // Need to explicitly specify the values in the next state.
        if (!__done__) {
            contentsP = contents;
            countP = count;
        }
    }

    procedure popQ()
        returns (
            contentsP : [index_t]data_t,
            countP : integer,
            out : data_t
        )
        modifies __min__, __min_idx__;
        // requires ( op == PUSH ); // Useful for printing execution traces
        /*
        requires (op == POP);
        // Must not be empty
        requires ( exists (i : integer) ::
                    (i >= 0 && i <= END) &&
                    contents[i]._1 >= 0 );
        ensures (countP == count - 1);
        */
    {
        __min__ = contents[0];
        __min_idx__ = 0; 

        // Find the minimum
        for (i : integer) in range(0, END) {
            if (contents[i] != NULL_EVENT) {
                if (__min__ == NULL_EVENT) {
                    __min__ = contents[i];
                    __min_idx__ = i;
                }
                else {
                    // Earliest deadline first scheduling
                    // Think about how to incorporate ddl.
                    // Multiple ways to generate priorities
                    // based on precedence graph.

                    // By assigning fixed priorities, choosing
                    // one of the possible assignments.

                    // Two things to look into:
                    // 1. single fixed assignemnt can capture ddl.
                    // 2. earliest ddl first is optimal in terms of feasibility.

                    // Lookup priority
                    if (priority[contents[i]._4] < priority[__min__._4]) {
                        __min__ = contents[i];
                        __min_idx__ = i;
                    }
                }
            }
        }

        out = __min__;
        contentsP = contents[__min_idx__ -> NULL_EVENT];
        if (out == NULL_EVENT) {
            countP = count;
        }
        else {
            countP = count - 1;
        }
    }

    init {

        /*********************
         * Initialize priority
         ********************/
        // Note: this should be "levels" of precedence graph
        // In C, it is based on deadlines and levels, encoded
        // in a 64 bit bit-vector. And it does earliest deadline
        // first scheduling.
        //
        // Parallel track
        // A -> B -> C
        //  \-> E -> F
        // B & E takes 9ms to exec.
        // If C deadline is violated, sets a state var true.
        // C and F both have a deadline of 10ms.
        // Verify the state variable never reaches true.
        // E -> F -> B -> C
        // B -> E -> C -> F

        // If B, C, E, F run on different cores and do not share the
        // same state variables. It is fine to have any exec. order nondet.ly.
        // But if they different deadlines and they have deadline handlers,
        // the story is different because now we nondeterminism introduced
        // in the system.

        // LF is deterministic if ddl is not violated.

        // MIT

        // Interleaving semantics. 
        // 
        // Soundness.
        // Is a particular valuation of the state variables of reactors reachable?
        // Can be answered under the assumption ddl not violated.
        //
        priority[A_STARTUP] = 0;
        priority[B_STARTUP] = 0;
        priority[B_IN] = 1;

        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        __done__ = false;
        __min__ = NULL_EVENT;

        /*****************
         * STARTUP actions
         *****************/
        count = 2;
        contents[0] = { 0, A, A, A_STARTUP, 0, true };
        contents[1] = { 0, B, B, B_STARTUP, 0, true }; // make unroll faster

        // Step 1:
        // count = 2;
        // contents[0] = { 0, A, B, B_IN, 1, true };
        // contents[1] = { 0, A, A, A_STARTUP, 0, true };

        // Make the rest NULL_EVENT
        for (i : integer) in range(2, END) {
            contents[i] = NULL_EVENT;
        }
    }

    next {
        case
            (op == PUSH) : {
                call (contents', count') = pushQ();
            }
            (op == POP) : {
                call (contents', count', out') = popQ();
            }
        esac;
    }

    control {
        vPush = verify(pushQ);
        vPop = verify(popQ);
        check;
        print_results;
        vPush.print_cex();
        vPop.print_cex();
    }
}

module RTI {
    type * = EventQ.*;
    const * = EventQ.*;

    // TODO: rename these variable to "X_to_Y".
    // Auto-generated
    input in_A : event_t;  
    input in_B : event_t;

    output out_A : event_t;
    output out_B : event_t;
    /**
     * Notes:
     * These two queues can potentially be merged
     * and produce an _out_reaction array.
     * Similarly, A and B are merged into one module
     * containing all reactions and state variables.
     * This allows all declarations to be in one local scope.
     * But need to check whether this is actually useful,
     * since we can do the same things in main module.
     *
     * The same _out_reaction can be fed to both A and B,
     * where they selectively react to triggers with
     * them as the destinations.
     */

    // Shared
    var NULL_EVENT : event_t;

    // Event queue variables 
    // Both queues share these two fields for now.
    // If need be, separate them and create a NoOp operation for queues.
    var eq_op : op_t;
    var eq_data : data_t;
    var eq_out : data_t;

    // Reaction queue variables
    var rq_op : op_t;
    var rq_data : data_t;
    var rq_out : data_t;

    // Event queue and reaction queue
    instance event_q : EventQ(op : (eq_op), data : (eq_data), out : (eq_out));
    instance reaction_q : ReactionQ(op : (rq_op), data : (rq_data), out : (rq_out));

    // The current clock value
    var t : instant_t;

    /**
     * Load an input to push into either eq or rq.
     */
    procedure push_event()
        returns (
            _op : op_t,
            _data : data_t
        )
    {
        // If the incoming event has the same tag as current time
        // push the event into reaction queue, otherwise into event queue.

        _op = PUSH;

        if (in_A != NULL_EVENT) {
            _data = in_A;
        }
        else {
            if (in_B != NULL_EVENT) {
                _data = in_B;
            }
        }
    }

    /**
     * Selects a queue to pop from.
     *
     * TODO: remove this procedure and set
     * op directly in next{}.
     */
    procedure pop_events()
        returns (
            _op : op_t
        )
    {
        _op = POP;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        t = 0;

        eq_op = PUSH;
        eq_data = NULL_EVENT;

        rq_op = PUSH;
        rq_data = NULL_EVENT;

        eq_out = NULL_EVENT;
        rq_out = NULL_EVENT;

        out_A = NULL_EVENT;
        out_B = NULL_EVENT;
    }

    /**
     * The next() function facilitates the transition of
     * the system composed by reactors.
     *
     * The next() function pops events from the queue,
     * pushes events into the queue,
     * and check to see if it can advance time.
     */
    next {
        /**
         * 1. Check if there are input events. If so, push them into
         *    appropriate queues (might take multiple steps).
         * 2. If there are no more input events from reactors, pop from 
         *    reaction queue first. When the reaction queue becomes empty, 
         *    pop from event queue and advance time.
         */
        if (in_A != NULL_EVENT || in_B != NULL_EVENT) {

            // TODO: Here we spend an extra UCLID step to process input data
            // See if this step can be removed.
            if (in_A._1 == t || in_B._1 == t) {
                // Push to reaction queue if the event happens at the same instant.
                call (rq_op', rq_data') = push_event();

                // Event queue does nothing.
                eq_op' = PUSH;
                eq_data' = NULL_EVENT;
            }
            else {
                // Push to event queue if it is a future action.
                call (eq_op', eq_data') = push_event();

                // Reaction queue does nothing.
                rq_op' = PUSH;
                rq_data' = NULL_EVENT;
            }
        }
        else {
            // At this point there are no more events 
            // from both reactors, pop from queue

            // Pop from reaction queue if it is not empty.
            if (reaction_q.count > 0) {
                rq_op' = POP;
                rq_data' = NULL_EVENT;

                eq_op' = PUSH; // Pushing a NULL_EVENT is similar to NoOp.
                eq_data' = NULL_EVENT;
            }
            else {
                rq_op' = PUSH;
                rq_data' = NULL_EVENT;

                eq_op' = POP;
                eq_data' = NULL_EVENT;
            }
        }


        /**
         * Distribute events to appropriate reactors
         */
        if (rq_out' != NULL_EVENT) {
            if (rq_out'._3 == A) {
                out_A' = rq_out';
                out_B' = NULL_EVENT;
            }
            else {
                if (rq_out'._3 == B) {
                    out_B' = rq_out';
                    out_A' = NULL_EVENT;
                }
                else {
                    if (rq_out'._3 == NULL) {
                        out_A' = NULL_EVENT;
                        out_B' = NULL_EVENT;
                    }
                }
            }

            /**
             * Update local clock
             */
            if (rq_out' == NULL_EVENT) {
                t' = t;
            }
            else {
                t' = rq_out'._1;
            }
        }
        else {
            if (eq_out' != NULL_EVENT) {
                if (eq_out'._3 == A) {
                    out_A' = eq_out';
                    out_B' = NULL_EVENT;
                }
                else {
                    if (eq_out'._3 == B) {
                        out_B' = eq_out';
                        out_A' = NULL_EVENT;
                    }
                }
            }
            else {
                out_A' = NULL_EVENT;
                out_B' = NULL_EVENT;
            }

            /**
             * Update local clock
             */
            if (rq_out' == NULL_EVENT) {
                t' = t;
            }
            else {
                t' = rq_out'._1;
            }
        }

        // When the reaction queue is added, need to decide on a specific
        // queue to advance.
        // Advance event queue
        next(event_q);
        next(reaction_q);
    }

}

/******************************
 * A list of reactor instances.
 * This section should be auto-
 * generated by the transpiler.
 *****************************/
module Reactor_A {
    type * = Common.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;
    input __in__ : event_t;
    output __out__ : event_t;

    // LF inputs
    // There isn't any in reactor A.

    // LF state variables
    // There isn't any in reactor A.

    // LF outputs, to store values after reaction execution.
    var _out : event_t; // output _out:int;

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    // TODO

    // A list of reactions
    procedure rxn_startup()
        returns (ret : event_t)
    {
        // Much of the information can be hardcoded into the program.
        // Variables will be introduced when there are runtime mutations.
        ret = { t,  // Current time 
                A,  // Origin, which is A in this case
                B,  // Destination, can be generated based on the precedence graph at compiletime
                B_IN, // Trigger for destination
                1,  // Payload, which is 1 based on the target code
                true // True since this is not an NULL_EVENT.
                };
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        __out__ = NULL_EVENT;
        _out = NULL_EVENT;

        // Note; startup action initialization now in EventQ init{}.

        assume(__in__ == NULL_EVENT);
    }

    next {
        if (__in__ != NULL_EVENT) {
            case
                (__in__._4 == A_STARTUP) : {
                    call (_out') = rxn_startup();
                    // TODO: push _out' into the outbound buffer
                    // can be implemented using an array and 2 vars (hd & tl)
                }
            esac

            // TODO: pop event from outbound buffer
            __out__' = _out';
        }
        else {
            __out__' = NULL_EVENT;
        }
    }
}


module Reactor_B {
    type * = Common.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;
    input __in__ : event_t;
    output __out__ : event_t;

    // LF inputs
    var _in : event_t; 

    // LF state variables
    var s : integer;

    // LF outputs, to store values after reaction execution.
    var _out : event_t; // output _out:int;

    // A list of reactions
    procedure rxn_startup()
        returns (ret : event_t,
                 sP : integer)
    {
        // Reaction body
        sP = 0;

        // Since this reaction does not have
        // any antidependency, we can simply
        // set ret to NULL_EVENT.
        ret = NULL_EVENT;
    }

    procedure rxn__in()
        returns (ret : event_t,
                 sP : integer)
    {
        // Reaction body
        sP = s + _in._5;

        // This reaction does not return anything.
        // TODO: see if we can assert that this reaction
        // (or reactor B in general) can only return NULL.
        ret = NULL_EVENT;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        __out__ = NULL_EVENT;
        _out = NULL_EVENT;
        _in = NULL_EVENT;
        s = -999; // Use this dummy value for now to denote init value.
        // s = 0; // Make unroll faster

        // Note; startup action initialization now in EventQ init{}.

        assume(__in__ == NULL_EVENT);
    }

    // TODO: find out how to detect the presence of 
    // multiple inputs. Reaction is triggered when
    // the presence of a trigger (or absence of which)
    // is known completely.
    next {
        // Check the value of __in__ and distribute
        // it to appropriate trigger, since we only
        // take one input event at a UCLID step.
        if (__in__ != NULL_EVENT) {
            if (__in__._4 == B_STARTUP) {
                _in' = __in__;
            }
            else {
                if (__in__._4 == B_IN) {
                    _in' = __in__;
                }
            }
            // ... matching other triggers ...
        }
        else {
            _in' = NULL_EVENT; // reset _in
        }

        // Match triggers with reactions
        if (_in._4 == B_STARTUP) {
            call (_out', s') = rxn_startup();
            __out__' = _out';
        }
        else {
            if (_in._4 == B_IN) {
                // Besides an out event, rxn__in() has the
                // side effect of modifying s, which is returned
                // here and put into s'.
                call (_out', s') = rxn__in();
                
                // TODO: push _out' into the outbound buffer
                // can be implemented using an array and 2 vars (hd & tl)

                // TODO: pop event from outbound buffer
                __out__' = _out';
            }
            else {
                // if () { ... other triggers ... }
                
                // If nothing matches, return a NULL_EVENT.
                __out__' = NULL_EVENT;
            }
        }
    }
}


/*****************
 * The main module
 *****************/
module main {
    type * = EventQ.*;

    // Channel between RTI and reactors
    var A_to_RTI : event_t;
    var B_to_RTI : event_t;
    var RTI_to_A : event_t;
    var RTI_to_B : event_t;

    var NULL_EVENT : event_t;

    // TODO: rename RTI and A's input/output var names to indicate direction
    instance rti : RTI(in_A : (A_to_RTI), out_A : (RTI_to_A),
                        in_B : (B_to_RTI), out_B : (RTI_to_B));
    instance a : Reactor_A(t : (rti.t), __in__ : (RTI_to_A), __out__ : (A_to_RTI));
    instance b : Reactor_B(t : (rti.t), __in__ : (RTI_to_B), __out__ : (B_to_RTI));

    init {
        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        A_to_RTI = NULL_EVENT;
        B_to_RTI = NULL_EVENT;
        RTI_to_A = NULL_EVENT;
        RTI_to_B = NULL_EVENT;

        // A convenient test case
        /*
        A_to_RTI = { 0, A, A, A_OUT, 10, true };
        */
    }

    next {
        next(rti); 
        next(a);
        next(b);
    }

    // A set of properties that are potentially helpful
    
    // Ensure RTI behaves correctly
    property[LTL] A_receives_valid_event : G(a.__in__._3 == A || a.__in__._3 == NULL); 
    property[LTL] B_receives_valid_event : G(b.__in__._3 == B || b.__in__._3 == NULL); 

    // Verify behavior of the reactor system
    property[LTL] s_is_eventually_1 : F(b.s == 1);
    property[LTL] s_value_that_always_hold : G(b.s == -999 || b.s >= 0);
    property[LTL] s_does_not_incr_until_input : W((b.s == 0 || b.s == -999), (b._in._4 == B_IN));

    control {
        // v = induction;
        v = bmc(20);
        check;
        print_results;
        v.print_cex(
                    rti.t,
                    rti.event_q.contents, 
                    rti.event_q.op,
                    rti.event_q.data,
                    rti.event_q.count,
                    rti.reaction_q.contents, 
                    rti.reaction_q.op,
                    rti.reaction_q.data,
                    rti.reaction_q.count,
                    rti.eq_op,
                    rti.eq_data,
                    rti.eq_out,
                    rti.rq_op,
                    rti.rq_data,
                    rti.rq_out,
                    rti.out_A,
                    rti.out_B,
                    rti.in_A,
                    rti.in_B,
                    a.__in__,
                    a.__out__,
                    b.__in__,
                    b.__out__,
                    b._in,
                    b.s
                    );
    }
}

