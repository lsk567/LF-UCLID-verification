/**
 * Defines a non-deterministic event queue and reaction queue.
 *
 * The queue can opportunistically pop any number of events
 * with minimum time tags (EventQ) and minimum levels (ReactionQ).
 * 
 * The arbitrary delay can be modeled at either the pqueue side
 * or the reactor side (by adding a non-deterministic start counter).
 * In this case, it is explicitly modeled at the pqueue side,
 * since it has the advantage of reducing schedule conflicts (e.g.
 * sending reactors new events during its delay period).
 * 
 * However, the current formulation does not address the conflict
 * when a reaction that takes multiple steps to execute receives a
 * new event. This does not happen in simple systems, but might apear
 * in complex ones.
 *
 * The design philosophy is to leave as much work to the infrastrucutre
 * as possible and make reactors as simple as possible.
 *
 * Roadmap:
 * 1. Create a pqueue that combines EventQ and ReactionQ (i.e. pop events
 *    with the earliest time tag and the smallest level).
 * 2. Build event distribution directly into pqueue and do not use
 *    instantiations to conserve steps.
 */

module Scheduler
{
    type * = Queue.*;
    define * = Queue.*;
    const * = Queue.*;

    var NULL_EVENT : data_t;

    input op : op_t;
    input data : queue_t;
    
    var out : queue_t;

    var contents : queue_t;
    var count : integer;

    var step : integer; // Keep track of the current UCLID step

    var level : [trigger_id_t]integer;

    procedure push()
        modifies contents, count;
    {
        var index : integer;
        var elem : data_t;
        index = 1;

        for (i : integer) in range(1, SIZE) {
            if (get(contents, i) == NULL_EVENT) {
                elem = get(data, index);
                contents = set(contents, i, elem);
                if (elem != NULL_EVENT) {
                    count = count + 1;
                    index = index + 1;
                }
            }
        }
    }

    /*
    Notes:
    1. If inQ is defined using "exists", be careful not to introduce
        duplicate variable names. For example, after inlining,
        we will get forall (i : integer) :: exists (i : integer) :: ...
        which will cause collision.
    2. "get(out, i) != NULL_EVENT ==>" must be in the clause somehow.
        The reason could be that "out" is set first. If it contains NULL_EVENT,
        then the paths will be blocked by assume, because contents does not
        contain NULL_EVENT.
    */
    procedure pop()
        modifies contents, count, out;
    {
        havoc out;
        assume(forall (i : integer) :: 
            get(out, i) != NULL_EVENT ==>
            (
                // 1. Select element from contents array
                inQ(contents, get(out, i)) 
                // 2. Out contains the same number of elem.
                && countE(out, get(out, i)) == countE(contents, get(out, i)) 
                // 3. The minimum value preserve the same index.
                && get(contents, i) == get(out, i) 
                // 4. Elements have minimum time tag
                // The below property does not enforce the popping of ALL minimum elems
                && !(exists (e : event_t) :: (e != NULL_EVENT) && inQ(contents, e) && e._1 < get(out, i)._1) 
                // [Not needed with clause 6 in place] Pop all min elems, strengthening the previous clause
                // && (forall (e : event_t) :: (inQ(contents, e) && e._1 == get(out, i)._1) ==> inQ(out, e))
                // 5. Out of the events with the minimum time tag, select the ones with the front most level
                && !(exists (e : event_t) :: (e != NULL_EVENT) && inQ(contents, e) && e._1 == get(out, i)._1 &&
                     level[e._4] < level[get(out, i)._4])
                // 6. Strengthening the previous clause to pop ALL satisfying elements
                && (forall (e : event_t) :: (e != NULL_EVENT) && inQ(contents, e) && e._1 == get(out, i)._1 &&
                     level[e._4] == level[get(out, i)._4] ==> inQ(out, e)) 
            )
        );
        // 7. Pop non-null events if possible.
        assume(countQ(contents) > 0 ==> countQ(out) > 0);

        for (i : integer) in range(1, SIZE) {
            if (get(out, i) != NULL_EVENT) {
                contents = set(contents, i, NULL_EVENT);
            }
        }
        count = count - countQ(out);
    }

    init {
        step = 0;
        NULL_EVENT = {
            // {-1, -1},
            -1,
            NULL,
            NULL,
            NULL_NULL,
            UNKNOWN,
            -1,
            false
        };

        assume(op == POP);
        count = 5;
        /*
        contents = {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            {{2,3}, A, C, C_IN, BOOL, 2, true},
            {{4,3}, A, C, C_IN, BOOL, 2, true},
            {{3,3}, A, C, C_IN, INT, 2, true}
        };
        */
        contents = {
            {1, A, B, B_IN, INT, 10, false},
            {2, A, C, B_IN, BOOL, 2, true},
            {2, A, C, B_STARTUP, BOOL, 2, true},
            {2, A, C, C_STARTUP, BOOL, 2, true},
            {3, A, C, C_IN, INT, 2, true}
        };
        /*
        contents = {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        };
        */

        out = {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        };


        /*
        assume(data == {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });
        */

        // File specific
        level[A_STARTUP] = 1;
        level[B_STARTUP] = 2;
        level[C_STARTUP] = 2;
        level[B_IN]      = 3;
        level[C_IN]      = 3;
    }

    next {
        /*
        assume(data == {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });
        */
        step' = step + 1;
        case
            (op == PUSH) : {
                call () = push();
            }
            (op == POP) : {
                call () = pop();
            }
        esac

        assume(op == POP);
    }

    
    property[LTL] test : !F(contents == {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });
    
    // property[LTL] test : !F(count == 3 && step == 1);

    control {
        v = bmc(5);
        check;
        print_results;
        v.print_cex(contents, count, op, data, out);
    }
}
