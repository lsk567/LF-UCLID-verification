/**
 * Defines event queue and reaction queue.
 */

module EventQ
{
    type * = Queue.*;
    define * = Queue.*;
    const * = Queue.*;

    var NULL_EVENT : data_t;

    input op : op_t;
    input data : queue_t;
    
    var out : queue_t;

    var contents : queue_t;
    var count : integer;

    procedure pushQ()
        modifies contents, count;
    {
        var index : integer;
        var elem : data_t;
        index = 1;

        for (i : integer) in range(1, SIZE) {
            if (get(contents, i) == NULL_EVENT) {
                elem = get(data, index);
                contents = set(contents, i, elem);
                if (elem != NULL_EVENT) {
                    count = count + 1;
                    index = index + 1;
                }
            }
        }
    }

    /*
    Notes:
    1. If inQ is defined using "exists", be careful not to introduce
        duplicate variable names. For example, after inlining,
        we will get forall (i : integer) :: exists (i : integer) :: ...
        which will cause collision.
    2. "get(out, i) != NULL_EVENT ==>" must be in the clause somehow.
        The reason could be that "out" is set first. If it contains NULL_EVENT,
        then the paths will be blocked by assume, because contents does not
        contain NULL_EVENT.
    */
    procedure popQ()
        modifies contents, count, out;
    {
        /*
        var out : queue_t;
        var index : integer;
        index = 1;
        assume();
        
        for (i : integer) in range(1, SIZE) {
            if (get(out, i) != NULL_EVENT) {
                // Remove the event from the content array
                content = set(contents, i, NULL_EVENT);
            }
        }
        count = count - countQ(out); 
        */


        havoc out;
        // The queue contains elements that are the minimum of all 
        // 1. Events in out must precede contents if not NULL_EVENT
        // 2. If countEvent(e, contents) > 0 (has duplicate events),
        //    countEvent(e, out) <= countEvent(e, contents)
        assume(forall (i : integer) :: 
            get(out, i) != NULL_EVENT ==>
            (
                inQ(contents, get(out, i)) // Select element from contents array
                && !(exists (e : event_t) :: inQ(contents, e) && e._1 < get(out, i)._1) // Elements have minimum time tag
                && countE(out, get(out, i)) <= countE(contents, get(out, i)) // Out contains the same number of elem.
            )
        );


        count = 5;
    }

    init {
        NULL_EVENT = {
            // {-1, -1},
            -1,
            NULL,
            NULL,
            NULL_NULL,
            UNKNOWN,
            -1,
            false
        };

        count = 5;
        /*
        contents = {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            {{2,3}, A, C, C_IN, BOOL, 2, true},
            {{4,3}, A, C, C_IN, BOOL, 2, true},
            {{3,3}, A, C, C_IN, INT, 2, true}
        };
        */
        contents = {
            {1, A, B, B_IN, INT, 10, false},
            {5, A, C, C_IN, BOOL, 2, true},
            {2, A, C, C_IN, BOOL, 2, true},
            {4, A, C, C_IN, BOOL, 2, true},
            {3, A, C, C_IN, INT, 2, true}
        };

        out = {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        };

        /*
        contents = {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        };
        */

        assume(op == POP);

        /*
        assume(data == {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });
        */
    }

    next {
        /*
        assume(data == {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });
        */

        case
            (op == PUSH) : {
                call () = pushQ();
            }
            (op == POP) : {
                call () = popQ();
            }
        esac

        assume(op == POP);
    }

    property[LTL] test : !F(out == {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });

    control {
        v = bmc(5);
        check;
        print_results;
        v.print_cex(contents, count, op, data, out);
    }
}
