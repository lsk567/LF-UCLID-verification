/**
 * Potential bug in popQ
 *
 * Defines event queue and reaction queue.
 */

module EventQ
{
    type * = Queue.*;
    define * = Queue.*;
    const * = Queue.*;

    var NULL_EVENT : data_t;

    input op : op_t;
    input data : queue_t;
    
    var out : queue_t;

    var contents : queue_t;
    var count : integer;

    procedure pushQ()
        modifies contents, count;
    {
        var index : integer;
        var elem : data_t;
        index = 1;

        for (i : integer) in range(1, SIZE) {
            if (get(contents, i) == NULL_EVENT) {
                elem = get(data, index);
                contents = set(contents, i, elem);
                if (elem != NULL_EVENT) {
                    count = count + 1;
                    index = index + 1;
                }
            }
        }
    }

    procedure popQ()
        modifies contents, count, out;
    {
        // The expected output should be all output either in contents
        // or NULL_EVENT, yet the actual output contains elements that
        // are random. inQ does not seem to work in this case.

        havoc out;
        // The queue contains elements that are the minimum of all 
        // 1. Events in out must precede contents if not NULL_EVENT
        // 2. If countEvent(e, contents) > 0 (has duplicate events),
        //    countEvent(e, out) <= countEvent(e, contents)
        assume(forall (j : integer) :: 
            // i > 0 && i <= SIZE &&
            get(out, j) != NULL_EVENT ==>
            inQ(contents, get(out, j))
        );
    }

    init {
        NULL_EVENT = {
            // {-1, -1},
            -1,
            NULL,
            NULL,
            NULL_NULL,
            UNKNOWN,
            -1,
            false
        };

        count = 5;
        /*
        contents = {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            {{2,3}, A, C, C_IN, BOOL, 2, true},
            {{4,3}, A, C, C_IN, BOOL, 2, true},
            {{3,3}, A, C, C_IN, INT, 2, true}
        };
        */
        contents = {
            {1, A, B, B_IN, INT, 10, false},
            {5, A, C, C_IN, BOOL, 2, true},
            {2, A, C, C_IN, BOOL, 2, true},
            {4, A, C, C_IN, BOOL, 2, true},
            {3, A, C, C_IN, INT, 2, true}
        };

        out = {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        };

        /*
        contents = {
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        };
        */

        assume(op == POP);

        /*
        assume(data == {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });
        */
    }

    next {
        /*
        assume(data == {
            {{1,2}, A, B, B_IN, INT, 10, false},
            {{5,3}, A, C, C_IN, BOOL, 2, true},
            NULL_EVENT,
            NULL_EVENT,
            NULL_EVENT
        });
        */

        case
            (op == PUSH) : {
                call () = pushQ();
            }
            (op == POP) : {
                call () = popQ();
            }
        esac

        assume(op == POP);
    }

    property[LTL] test : G(count == 0);

    control {
        v = bmc(5);
        check;
        print_results;
        v.print_cex(contents, count, op, data, out);
    }
}
