/*
 Diagram.
 +--------------------------------------+
 |                                      |
 |   Main                               |
 |                                      |
 |               advance?               |
 |        +--------------------+        |
 |        |                    |        |
 |        |                    v        |
 | +------+------+  time   +---+---+    |
 | | LogicalTime +<--------+ Clock |    |
 | +------+------+         ++--+---+    |
 |        ^         time    | ||        |
 |        |      +----------+ || time   |
 |        |      |      +-----+|        |
 |        |      v      |      v        |
 |        |    +-+-+    v    +-+-+      |
 |        |    | A +--/ 3 /->+ B |      |
 |        |    +-+-+         +-+-+      |
 |        |      |             |        |
 |        +------+-------------+        |
 |              all_ghost?              |
 |                                      |
 +--------------------------------------+
 */

/**
 * LF Helper Modules
 */
module Common {
    type ename_t = enum { A_STARTUP, B_INCR, GHOST }; // Event name
    //type rname_t = enum { A, B }; // Reactor names
    type event_t = record { 
            name : ename_t,
            timestamp : integer, // Assume MSEC
            value : integer, // ideally anytype, int for now.
            // This boolean field complements
            // value, since undefined is a legit
            // value in LF. If undefined = true,
            // ignore value in the value field.
            undefined : boolean, // TODO: remove
            // If present = true, the event is a
            // ghost / empty event for UCLID5
            // syntactic needs (cannot have absent
            // output. Another interpretation is
            // notifying the main module of its
            // current idleness by firing an empty
            // event.)
            // TODO: see if this is still needed
            // when the symbolic empty event is 
            // in use.
            present : boolean
            // The below values are mostly for
            // debugging purposes, connections
            // are defined in module instan-
            // -tiation.
            // orig : rname_t,
            // dest : rname_t
        };
    // For future extension
    /*
    type tag_t = record { 
            logical : boolean, // property of action
            timestamp : integer,
            microstep : integer
        };
    */

    // NOTE: see if this is implemented
    // const ghost_event =
    // const ghost_event.name = GHOST;

    // TODO: use symbolic const to denote empty event?
    // const empty_event : event_t

    /*
    type portmap_t = record {
        STARTUP : ename_t,
        INCR : ename_t,
        GHOST : ename_t
    };
    */
}

// LogicalTime module controls the advancement of
// logical time in this UCLID5 formulation of LF.
module Time {
    // Inputs from reactors
    // input a_out_ghost : boolean;
    // input b_out_ghost : boolean;

    // If true, there are only trivial events in the system.
    // The logical time should advance to trigger non-trivial
    // events.
    input all_ghost : boolean;

    // Input from clock
    // Currently dummy but could integrate clock calc,
    input clock : integer;

    // Output command to clock
    output advance : boolean;
    output offset : integer;

    // Advance time when both outputs are ghost
    // define next_time(ag, bg : boolean) : boolean
    // = (ag && bg);

    /*
    procedure update_adv(_all_ghost : boolean)
        modifies advance;
    {
        advance = _all_ghost;
    }
    */

    init {
        advance = true; // Since all events are init to be GHOST

        // TODO: set offset to the minimum logical
        // time required to produce a non-GHOST event,
        // so that we don't have to wait for something
        // nontrivial tick-by-tick.
        offset = 1;
    }

    next {
        // advance' = next_time(a_out_ghost, b_out_ghost);
        
        advance' = all_ghost;
        // call update_adv(all_ghost);
    }

}

module Clock {
    input advance : boolean;
    input offset : integer;
    output t_out : integer; // This output is unnecessary.
    var t : integer;

    procedure incr_time(i : integer)
        returns (ret : integer)
        modifies t;
    {
        if (advance) {
            t = t + i;
            ret = t;
        } else {
            ret = t;
        }
    }

    init {
        t = 0;
    }

    next {
        call (t_out') = incr_time(offset);
    }
}

module Delay {
    type * = Common.*;

    // Ports
    input _delay : integer; // delay parameter
    input _time : integer;
    input _in : event_t;
    output _out : event_t;

    // Event
    var buffer : event_t; // A queue for holding multiple incoming events? 
    var buffer_empty : boolean;
    var ghost_event : event_t;
    var portmap : [ename_t]ename_t;

    // DEBUG
    output __d_buffer__ : event_t;

    // State variable of interest
    // var delay : integer;
    var time_in : integer;

    procedure check_delay(b : event_t)
        returns (ret : event_t)
    {
        if (_time - time_in >= _delay) {
            ret = b;
        } else {
            ret = ghost_event;
        }
    }

    procedure update_state(e : event_t)
        modifies buffer, buffer_empty, time_in;
    {
        if (e.name != GHOST) {
            buffer = ghost_event;
            buffer_empty = true;
        }

        if (buffer_empty && _in.name != GHOST) {
            buffer = _in;
            buffer_empty = false;
            time_in = _time;
        }
    }

    init {
        // Required for every reactor
        ghost_event.name = GHOST;
        ghost_event.timestamp = -1;
        ghost_event.value = -1;
        ghost_event.undefined = false;
        ghost_event.present = false;

        // Instantiate portmap
        portmap[A_STARTUP] = B_INCR;
        portmap[B_INCR] = B_INCR; // Connection ends at B
        portmap[GHOST] = GHOST;

        buffer = ghost_event;
        buffer_empty = true;

        // ===========================
        // delay = 0; // 1 unit of delay
        time_in = 0;
    }

    next {
        call (_out') = check_delay(buffer);
        call update_state(_out');

        // DEBUG
        __d_buffer__' = buffer';
    }
}

/**
 * A list of reactors
 */
module A {
    // Import all types in the Common module
    // to the current namespace, otherwise
    // a "Common." prefix is needed (i.e.
    // Common.event_t).
    type * = Common.*;

    // Ports
    input _time : integer;
    output _out : event_t;

    // Event
    var buffer : event_t; // A queue for holding multiple incoming events? 
    var buffer_empty : boolean;
    var ghost_event : event_t;
    var portmap : [ename_t]ename_t;

    // DEBUG
    output __a_buffer__ : event_t;

    procedure reaction_startup(buffer : event_t)
        returns (ret : event_t)
    {
        // Update event name (dest. port)
        // before sending
        ret = buffer;
        ret.name = portmap[buffer.name];
    }

    init {
        // Required for every reactor
        ghost_event.name = GHOST;
        ghost_event.timestamp = -1;
        ghost_event.value = -1;
        ghost_event.undefined = false;
        ghost_event.present = false;

        // Instantiate portmap
        // Portmap provides a map with which
        // before sending events to downstream
        // reactor, we change its event name 
        // to the name of downstream port.
        portmap[A_STARTUP] = B_INCR;
        portmap[B_INCR] = B_INCR; // Connection ends at B
        portmap[GHOST] = GHOST;

        // ====== Reactor Specific ======

        // Define startup reaction by
        // pushing an event to buffer
        buffer.name = A_STARTUP;
        buffer.timestamp = 0;
        buffer.value = 1;
        buffer.undefined = false;
        buffer.present = true;

        buffer_empty = false;
    }

    // Identical to LF scheduler
    next {
        // Trigger a reaction
        // Process buffer
        if (!buffer_empty) {
            // Handler for the startup reaction
            case 
                (buffer.name == A_STARTUP) : {
                    call (_out') = reaction_startup(buffer);
                }
            esac
        } else {
            _out' = ghost_event;
        }

        // Check for incoming new event
        // In this case we have none.
        buffer' = ghost_event;
        buffer_empty' = true;

        // DEBUG
        __a_buffer__' = buffer';
    }
}

module B {
    type * = Common.*;

    // Ports
    input _time : integer;
    input _in : event_t;
    output _out : event_t;

    // Event
    var buffer : event_t; // A queue for holding multiple incoming events? 
    var buffer_empty : boolean;
    var ghost_event : event_t;
    var portmap : [ename_t]ename_t;

    // DEBUG
    output __b_buffer__ : event_t;

    // State variable of interest
    var v : integer;

    //define event(i : integer, _n : ename_t) : event_t
    //= {_n, current_time, i, false, false};

    // Reaction incr.
    // Check if input is visible in procedure.
    // Here we adopt a functional style.
    procedure reaction_incr(buffer : event_t)
        returns (ret : event_t)
        modifies v;
    {
        // Reaction body
        v = v + buffer.value;

        // Output event
        // Define() does not work because it cannot
        // encode record in a non-imperative manner,
        // to correctly instantiate record, one needs
        // to assign each field individually.
        //ret = event(v, INCR);
        ret = buffer;
        ret.value = v;
        ret.name = portmap[buffer.name];
    }

    init {
        // Required for every reactor
        ghost_event.name = GHOST;
        ghost_event.timestamp = -1;
        ghost_event.value = -1;
        ghost_event.undefined = false;
        ghost_event.present = false;

        // Instantiate portmap
        portmap[A_STARTUP] = B_INCR;
        portmap[B_INCR] = B_INCR; // Connection ends at B
        portmap[GHOST] = GHOST;

        // ====== Reactor Specific ======

        // Buffer initially empty
        buffer = ghost_event;
        buffer_empty = true;

        // Initialize v to 0
        v = 1;
    }

    next {
        // Trigger a reaction
        // Process buffer
        if (!buffer_empty) {
            // Usually have a case statement for different
            // reaction, in this case, it is not needed since
            // it is only handling a startup reaction.
            // Simply fire event
            case 
                (buffer.name == B_INCR) : {
                    call (_out') = reaction_incr(buffer);
                }
            esac
        } else {
            _out' = ghost_event;
        }

        // Check for incoming new event
        if (_in.name != GHOST) {
            buffer' = _in;
            buffer_empty' = false;
        } else {
            buffer' = ghost_event;
            buffer_empty' = true;
        }

        // DEBUG
        // At the time of output, b's current unprocessed event
        __b_buffer__' = buffer';
    }
}

/**
 * Main execution 
 */
module main {
    type * = Common.*;

    // Inputs/Outputs
    var a_out : event_t;
    var b_out : event_t;
    var d_out : event_t;
    var time : integer;
    var adv : boolean;
    var off : integer;

    // Const
    var d_delay : integer;

    // DEBUG
    var __a_buffer__ : event_t;
    var __b_buffer__ : event_t;
    var __d_buffer__ : event_t;

    // System const
    var ghost_event : event_t;

    define _all_ghost(_a_out, _b_out, _d_out : event_t) : boolean
    = (_a_out.name == GHOST && _b_out.name == GHOST && 
        _d_out.name == GHOST);

    // Define connections between modules
    instance t : Time(all_ghost : (_all_ghost(a_out, b_out, d_out)),
                    clock : (time), advance : (adv),
                    offset : (off));
    instance c : Clock(advance : (adv), offset : (off),
                    t_out : (time));
    instance a : A(_time : (time), _out : (a_out),
                    __a_buffer__ : (__a_buffer__));
    instance d : Delay(_delay : (d_delay), _time : (time), 
                    _in : (a_out), _out : (d_out), 
                    __d_buffer__ : (__d_buffer__));
    instance b : B(_time : (time), _in : (d_out), _out : (b_out),
                    __b_buffer__ : (__b_buffer__));

    init {
        ghost_event.name = GHOST;
        ghost_event.timestamp = -1;
        ghost_event.value = -1;
        ghost_event.undefined = false;
        ghost_event.present = false;

        a_out = ghost_event;
        d_out = ghost_event;
        b_out = ghost_event;

        d_delay = 3; // Do not change during transition.

        time = 0;
        adv = false;
        off = 1;
    }

    // Expect 0,1
    next {
        // Evaluate logical time first
        next(c);

        // Evaluate reactions
        next(a);
        next(d);
        next(b);

        // See if we need to advance time 
        // based on the event flow.
        next(t);
    }

    // To see the steps of the model,
    // one way to do this is by specifying
    // a false invariant and have the solvers
    // print out examples
    invariant v_lt_zero : (b.v < -100);

    control {
        v = unroll(10);
        check;
        print_results;
        // v.print_cex(a_out, d_out, b_out, time, adv, off, __a_buffer__,
        //             __b_buffer__, __d_buffer__);
        v.print_cex(time, a_out, d_out, b_out, adv, off,
                    __a_buffer__, __d_buffer__, __b_buffer__);
    }
}
