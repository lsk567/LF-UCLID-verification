module main {
    
    type * = common.*;
    define * = common.*;
    const * = common.*;

    var trace_A : trace_t;
    var trace_B : trace_t;
    var trace_C : trace_t;

    // Derive axioms from the static information of the program.
    // Tag should appear in increasing order for a timeline.
    axiom(forall (i, j : step_t) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(get(trace_A, i)), g(get(trace_A, j)))
            || tag_same(g(get(trace_A, i)), g(get(trace_A, j)))));
    axiom(forall (i, j : step_t) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(get(trace_B, i)), g(get(trace_B, j)))
            || tag_same(g(get(trace_B, i)), g(get(trace_B, j)))));
    axiom(forall (i, j : step_t) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(get(trace_C, i)), g(get(trace_C, j)))
            || tag_same(g(get(trace_C, i)), g(get(trace_C, j)))));

    // Timestamp and microstep should be non-negative.
    axiom(forall (i : step_t) :: in_range(i)
        ==> (pi1(g(get(trace_A, i))) >= 0 && pi2(g(get(trace_A, i))) >= 0));
    axiom(forall (i : step_t) :: in_range(i)
        ==> (pi1(g(get(trace_B, i))) >= 0 && pi2(g(get(trace_B, i))) >= 0));
    axiom(forall (i : step_t) :: in_range(i)
        ==> (pi1(g(get(trace_C, i))) >= 0 && pi2(g(get(trace_C, i))) >= 0));
        
    // Each reactor only invokes its own reactions.
    axiom(forall (i : step_t) :: in_range(i) ==> N(get(trace_A, i)) == A2);
    axiom(forall (j : step_t) :: in_range(j) ==> N(get(trace_B, j)) == B1);
    axiom(forall (k : step_t) :: in_range(k) ==> N(get(trace_C, k)) == C1);

    // Connections
    axiom(forall (i : step_t) :: N(get(trace_A, i)) == A2
        ==> (exists (j : step_t) :: N(get(trace_B, j)) == B1
            && g(get(trace_B, j)) == tag_delay(g(get(trace_A, i)), A_out_B_in_DELAY)));
    axiom(forall (i : step_t) :: N(get(trace_B, i)) == B1
        ==> (exists (j : step_t) :: N(get(trace_C, j)) == C1
            && g(get(trace_C, j)) == tag_delay(g(get(trace_B, i)), B_out_C_in_DELAY)));
    
    // Same reaction cannot invoke twice in the same instant
    axiom(forall (i, j : step_t) :: (in_range(i) && in_range(j))
        ==> (i != j ==> ((N(get(trace_A, i)) == N(get(trace_A, j))
            ==> g(get(trace_A, i)) != g(get(trace_A, j))))));
    axiom(forall (i, j : step_t) :: (in_range(i) && in_range(j))
        ==> (i != j ==> ((N(get(trace_B, i)) == N(get(trace_B, j))
            ==> g(get(trace_B, i)) != g(get(trace_B, j))))));
    axiom(forall (i, j : step_t) :: (in_range(i) && in_range(j))
        ==> (i != j ==> ((N(get(trace_C, i)) == N(get(trace_C, j))
            ==> g(get(trace_C, i)) != g(get(trace_C, j))))));

    // Reaction precedence

    // Modeling logical actions using axioms:
    // If we have a logical action with minimum spacing, then
    // if we have a reaction that is triggered by the logical action
    // then there is a reaction that schedules the logical action
    // with a tag earlier wrt to the minimum spacing.

    // If there is an event in C, then there must be an event in A.
    
    init {
        // Initialize the traces
        // assume(get(trace_A, 0) == { A2, {10,0} });
        /*
        assume(get(trace_A, 0) == { A2, {1,0} });
        assume(get(trace_A, 1) == { A2, {3,0} });
        assume(get(trace_A, 2) == { A2, {5,0} });

        assume(get(trace_B, 0) == { B1, {1,0} });
        assume(get(trace_B, 1) == { B1, {3,0} });
        assume(get(trace_B, 2) == { B1, {5,0} });

        assume(get(trace_C, 0) == { C1, {1,0} });
        assume(get(trace_C, 1) == { C1, {3,0} });
        assume(get(trace_C, 2) == { C1, {5,0} });
        */
    }

    property prop : forall (i, j : step_t) ::
        (in_range(i) && in_range(j))
            ==> (invoke_before(0, get(trace_A, i), get(trace_C, j)))
                ==> !(exists (k : step_t) ::
                    invoke_before(0, get(trace_A, i), get(trace_B, k))
                    && invoke_before(0, get(trace_B, k), get(trace_C, j)));


    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex();
    }
}
