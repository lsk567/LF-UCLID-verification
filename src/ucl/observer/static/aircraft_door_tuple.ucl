module app {

    type rxn_id_t = enum { NULL, A2, B1, C1 };
    type reactor_id_t = enum { A, B, C };

    // Reaction precedence relation
    define rxn_precede(r1, r2 : rxn_id_t) : boolean
    = (r1 == A2 && r2 == B1)
        || (r1 == B1 && r2 == C1)
        || (r1 == A2 && r2 == C1);

    // Reaction precedence relation
    define rxn_has_edge(r1, r2 : rxn_id_t) : boolean
    = (r1 == A2 && r2 == B1)
        || (r1 == B1 && r2 == C1);

    // Reachability relation derived from topology graph
    define rxn_reach(r1, r2 : rxn_id_t) : boolean
    = (r1 == A2 && r2 == B1)
        || (r1 == B1 && r2 == C1)
        || (r1 == A2 && r2 == C1);

    // Logical delays
    const A_out_B_in_DELAY : interval_t = 0;
    const B_out_C_in_DELAY : interval_t = 0;
}

module common {

    type * = app.*;
    define * = app.*;
    const * = app.*;

    /**
     * Time tag-related types and macros
     */
    type timestamp_t = integer;
    type interval_t  = integer;
    type microstep_t = integer;

    type tag_t = {
        timestamp_t,
        microstep_t
    };

    // Projection macros
    define pi1(t : tag_t) : timestamp_t = t._1;
    define pi2(t : tag_t) : interval_t = t._2;

    // Tag comparison
    define tag_later(t1 : tag_t, t2 : tag_t) : boolean
        = if (t1._1 > t2._1 || (t1._1 == t2._1 && t1._2 > t2._2)) then true else false;

    define tag_same(t1 : tag_t, t2 : tag_t) : boolean
        = if (t1 == t2) then true else false;

    define tag_earlier(t1 : tag_t, t2 : tag_t) : boolean
        = !tag_later(t1, t2) && !tag_same(t1, t2);

    // Tag algebra
    define tag_schedule(t : tag_t, i : interval_t) : tag_t
        = if (i < 0) then t else (if (i == 0) then { pi1(t), pi2(t) + 1 } else { pi1(t) + i, 0 });

    define tag_delay(t : tag_t, i : interval_t) : tag_t
        = { pi1(t) + i, pi2(t) };

    // Only consider timestamp for now.
    define tag_diff(t1, t2: tag_t) : interval_t
        = pi1(t1) - pi1(t2);

    /**
     * Reaction graph + Topology graph
     * FIXME: perhaps there are more efficient encodings.
     */
    type _rxn_id_t = rxn_id_t;

    // Precedence in reaction graph
    define _rxn_precede(r1, r2 : _rxn_id_t) : boolean
    = rxn_precede(r1, r2);

    // Topology graph
    // FIXME: strict superset of precedence graph
    //          returns minimum delay
    define _rxn_has_edge(r1, r2 : _rxn_id_t) : boolean
    = rxn_has_edge(r1, r2);

    // Reachability derived from the topology graph
    define _rxn_reach(r1, r2 : _rxn_id_t) : boolean
    = rxn_reach(r1, r2);

    /**
     * Reaction invocation
     */
    type invocation_t = { _rxn_id_t, tag_t };

    // Projection macros
    define N(i : invocation_t) : _rxn_id_t = i._1;
    define g(i : invocation_t) : tag_t = i._2;

    /**
     * Message type
     */
    // msg_t should have a trigger and an arrival tag, which turns out to be
    // the same as invocation_t. In this model, the source reactor generates
    // an invocation, which the sink reactor can directly map on its timeline.
    type msg_t = invocation_t;

    /**
     * Trace
     */
    const START : integer = 0;
    const END : integer = 9;

    define in_range(num : integer) : boolean
    = num >= START && num <= END;

    type step_t = integer;
    type trace_t = { 
        invocation_t,
        invocation_t, 
        invocation_t, 
        invocation_t, 
        invocation_t, 
        invocation_t, 
        invocation_t, 
        invocation_t, 
        invocation_t, 
        invocation_t 
    };

    define get(tr : trace_t, i : step_t) : invocation_t
    = if (i == 0) then tr._1 else (
        if (i == 1) then tr._2 else (
            if (i == 2) then tr._3 else (
                if (i == 3) then tr._4 else (
                    if (i == 4) then tr._5 else (
                        if (i == 5) then tr._6 else (
                            if (i == 6) then tr._7 else (
                                if (i == 7) then tr._8 else (
                                    if (i == 8) then tr._9 else (
                                        if (i == 9) then tr._10 else (
                                            { NULL, {-1, -1} }
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    );

    define in_trace(_tr : trace_t, inv : invocation_t) : boolean
    = (exists (j : step_t) :: in_range(j) && get(_tr, j) == inv);

    /**
     * Invoke before & temporal operators
     */
    // Defining "invoke before"
    // Relies on assumption #2.
    define invoke_before(_i : interval_t, i1, i2 : invocation_t) : boolean
    = (_i == 0 
            ==> (tag_same(g(i1), g(i2))) 
                && _rxn_precede(N(i1), N(i2)))
        && (_i > 0 
            ==> (tag_diff(g(i1), g(i2)) == _i 
                && _rxn_reach(N(i1), N(i2))));
}

module main {
    
    type * = common.*;
    define * = common.*;
    const * = common.*;

    var trace_A : trace_t;
    var trace_B : trace_t;
    var trace_C : trace_t;

    // Derive axioms from the static information of the program.
    // Tag should appear in increasing order for a timeline.
    axiom(forall (i, j : step_t) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(get(trace_A, i)), g(get(trace_A, j)))
            || tag_same(g(get(trace_A, i)), g(get(trace_A, j)))));
    axiom(forall (i, j : step_t) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(get(trace_B, i)), g(get(trace_B, j)))
            || tag_same(g(get(trace_B, i)), g(get(trace_B, j)))));
    axiom(forall (i, j : step_t) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(get(trace_C, i)), g(get(trace_C, j)))
            || tag_same(g(get(trace_C, i)), g(get(trace_C, j)))));

    // Timestamp and microstep should be non-negative.
    axiom(forall (i : step_t) :: in_range(i)
        ==> (pi1(g(get(trace_A, i))) >= 0 && pi2(g(get(trace_A, i))) >= 0));
    axiom(forall (i : step_t) :: in_range(i)
        ==> (pi1(g(get(trace_B, i))) >= 0 && pi2(g(get(trace_B, i))) >= 0));
    axiom(forall (i : step_t) :: in_range(i)
        ==> (pi1(g(get(trace_C, i))) >= 0 && pi2(g(get(trace_C, i))) >= 0));
        
    // Each reactor only invokes its own reactions.
    axiom(forall (i : step_t) :: in_range(i) ==> N(get(trace_A, i)) == A2);
    axiom(forall (j : step_t) :: in_range(j) ==> N(get(trace_B, j)) == B1);
    axiom(forall (k : step_t) :: in_range(k) ==> N(get(trace_C, k)) == C1);

    // Connections
    axiom(forall (i : step_t) :: N(get(trace_A, i)) == A2
        ==> (exists (j : step_t) :: N(get(trace_B, j)) == B1
            && g(get(trace_B, j)) == tag_delay(g(get(trace_A, i)), A_out_B_in_DELAY)));
    axiom(forall (i : step_t) :: N(get(trace_B, i)) == B1
        ==> (exists (j : step_t) :: N(get(trace_C, j)) == C1
            && g(get(trace_C, j)) == tag_delay(g(get(trace_B, i)), B_out_C_in_DELAY)));
    
    // Same reaction cannot invoke twice in the same instant
    axiom(forall (i, j : step_t) :: (in_range(i) && in_range(j))
        ==> (i != j ==> ((N(get(trace_A, i)) == N(get(trace_A, j))
            ==> g(get(trace_A, i)) != g(get(trace_A, j))))));
    axiom(forall (i, j : step_t) :: (in_range(i) && in_range(j))
        ==> (i != j ==> ((N(get(trace_B, i)) == N(get(trace_B, j))
            ==> g(get(trace_B, i)) != g(get(trace_B, j))))));
    axiom(forall (i, j : step_t) :: (in_range(i) && in_range(j))
        ==> (i != j ==> ((N(get(trace_C, i)) == N(get(trace_C, j))
            ==> g(get(trace_C, i)) != g(get(trace_C, j))))));

    // Reaction precedence

    // Modeling logical actions using axioms:
    // If we have a logical action with minimum spacing, then
    // if we have a reaction that is triggered by the logical action
    // then there is a reaction that schedules the logical action
    // with a tag earlier wrt to the minimum spacing.

    // If there is an event in C, then there must be an event in A.
    
    init {
        // Initialize the traces
        // assume(get(trace_A, 0) == { A2, {10,0} });
        /*
        assume(get(trace_A, 0) == { A2, {1,0} });
        assume(get(trace_A, 1) == { A2, {3,0} });
        assume(get(trace_A, 2) == { A2, {5,0} });

        assume(get(trace_B, 0) == { B1, {1,0} });
        assume(get(trace_B, 1) == { B1, {3,0} });
        assume(get(trace_B, 2) == { B1, {5,0} });

        assume(get(trace_C, 0) == { C1, {1,0} });
        assume(get(trace_C, 1) == { C1, {3,0} });
        assume(get(trace_C, 2) == { C1, {5,0} });
        */
    }

    property prop : forall (i, j : step_t) ::
        (in_range(i) && in_range(j))
            ==> (invoke_before(0, get(trace_A, i), get(trace_C, j)))
                ==> (exists (k : step_t) ::
                    invoke_before(0, get(trace_A, i), get(trace_B, k))
                    && invoke_before(0, get(trace_B, k), get(trace_C, j)));


    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex();
    }
}
