/**
 * LF Helper Modules
 */
module common {
    type ename_t = enum { A_STARTUP, B_INCR, GHOST }; // Event name
    //type rname_t = enum { A, B }; // Reactor names
    type event_t = record { 
            name : ename_t,
            timestamp : integer, // Assume MSEC
            value : integer, // ideally anytype, int for now.
            // This boolean field complements
            // value, since undefined is a legit
            // value in LF. If undefined = true,
            // ignore value in the value field.
            undefined : boolean,
            // If present = true, the event is a
            // ghost / empty event for UCLID5
            // syntactic needs (cannot have absent
            // output. Another interpretation is
            // notifying the main module of its
            // current idleness by firing an empty
            // event.)
            // TODO: see if this is still needed
            // when the symbolic empty event is 
            // in use.
            present : boolean
            // The below values are mostly for
            // debugging purposes, connections
            // are defined in module instan-
            // -tiation.
            //orig : rname_t,
            //dest : rname_t
        };
    // For future extension
    /*
    type tag_t = record { 
            logical : boolean,
            timestamp : integer,
            step : integer
        };
    */

    // TODO: use symbolic const to denote empty event?
    // const empty_event : event_t;

    type portmap_t = record {
        STARTUP : ename_t,
        INCR : ename_t,
        GHOST : ename_t
    };
}

module A {
    // Import all types in the common module
    // to the current namespace, otherwise
    // a "common." prefix is needed (i.e.
    // common.event_t).
    type * = common.*;

    input current_time : integer;
    output _out : event_t;

    // Event mechanism
    var buffer : event_t; // A queue for holding multiple incoming events? 
    var buffer_empty : boolean;
    var ghost_event : event_t;
    var portmap : [ename_t]ename_t;

    procedure reaction_startup(buffer : event_t)
        returns (ret : event_t)
    {
        // Update event name (dest. port)
        // before sending
        ret = buffer;
        ret.name = portmap[buffer.name];
    }

    init {
        // Required for every reactor
        ghost_event.name = GHOST;
        ghost_event.timestamp = -1;
        ghost_event.value = -1;
        ghost_event.undefined = false;
        ghost_event.present = false;

        // Instantiate portmap
        // Portmap provides a map with which
        // before sending events to downstream
        // reactor, we change its event name 
        // to the name of downstream port.
        portmap[A_STARTUP] = B_INCR;
        portmap[B_INCR] = B_INCR; // Connection ends at B
        portmap[GHOST] = GHOST;

        // ====== Reactor Specific ======

        // Define startup reaction by
        // pushing an event to buffer
        buffer.name = A_STARTUP;
        buffer.timestamp = 0;
        buffer.value = 1;
        buffer.undefined = false;
        buffer.present = true;

        buffer_empty = false;
    }

    // Identical to LF scheduler
    next {
        // Trigger a reaction
        // Process buffer
        if (!buffer_empty) {
            // Handler for the startup reaction
            case 
                (buffer.name == A_STARTUP) : {
                    call (_out') = reaction_startup(buffer);
                }
            esac
        } else {
            _out' = ghost_event;
        }

        // Check for incoming new event
        // In this case we have none.
        buffer_empty' = true;
    }
}

module B {
    type * = common.*;

    input current_time : integer;
    input _in : event_t;
    output _out : event_t;

    // Event mechanism
    var buffer : event_t; // A queue for holding multiple incoming events? 
    var buffer_empty : boolean;
    var ghost_event : event_t;
    var portmap : [ename_t]ename_t;

    // State variable of interest
    var v : integer;

    //define event(i : integer, _n : ename_t) : event_t
    //= {_n, current_time, i, false, false};

    // Reaction incr.
    // Check if input is visible in procedure.
    // Here we adopt a functional style.
    procedure reaction_incr(buffer : event_t)
        returns (ret : event_t)
        modifies v;
    {
        // Reaction body
        v = v + buffer.value;

        // Output event
        // Define() does not work because it cannot
        // encode record in a non-imperative manner,
        // to correctly instantiate record, one needs
        // to assign each field individually.
        //ret = event(v, INCR);
        ret = buffer;
        ret.value = v;
        ret.name = portmap[buffer.name];
    }

    init {
        // Required for every reactor
        ghost_event.name = GHOST;
        ghost_event.timestamp = -1;
        ghost_event.value = -1;
        ghost_event.undefined = false;
        ghost_event.present = false;

        // Instantiate portmap
        portmap[A_STARTUP] = B_INCR;
        portmap[B_INCR] = B_INCR; // Connection ends at B
        portmap[GHOST] = GHOST;

        // ====== Reactor Specific ======

        // Buffer initially empty
        buffer_empty = true;

        // Initialize v to 0
        v = 1;
    }

    next {
        // Trigger a reaction
        // Process buffer
        if (!buffer_empty) {
            // Usually have a case statement for different
            // reaction, in this case, it is not needed since
            // it is only handling a startup reaction.
            // Simply fire event
            case 
                (buffer.name == B_INCR) : {
                    call (_out') = reaction_incr(buffer);
                }
            esac
        } else {
            _out' = ghost_event;
        }

        // Check for incoming new event
        if (_in.name != GHOST) {
            buffer' = _in;
            buffer_empty' = false;
        } else {
            buffer' = ghost_event;
            buffer_empty' = true;
        }
    }
}

module main {
    type * = common.*;

    var a_out : event_t;
    var b_out : event_t;
    var ghost_event : event_t;

    instance a : A(_out : (a_out));
    instance b : B(_in : (a_out), _out : (b_out));

    init {
        ghost_event.name = GHOST;
        ghost_event.timestamp = -1;
        ghost_event.value = -1;
        ghost_event.undefined = false;
        ghost_event.present = false;

        a_out = ghost_event;
        b_out = ghost_event;
    }

    // Expect 0,1
    next {
        next(a);
        next(b);
    }

    // To see the steps of the model,
    // one way to do this is by specifying
    // a false invariant and have the solvers
    // print out examples
    invariant v_lt_zero : (b.v < -100);

    control {
        v = unroll(5);
        check;
        print_results;
        v.print_cex(a_out, b_out);
    }
}
