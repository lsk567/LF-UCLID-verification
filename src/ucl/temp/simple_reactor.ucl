module A {
    output _out : integer;
    
    next {
        // Fire initial event
        // Though in this case, due to the
        // lack of time, module A repetitively
        // outputs this value.
        _out' = 1;
    }
}

module B {
    input _in : integer;
    output _out : integer;
    var v : integer;

    // Reaction incr.
    // Check if input is visible in procedure.
    // Here we adopt a functional style.
    procedure incr(i : integer)
        returns (ret : integer)
        modifies v;
    {
        v = v + i;
        ret = v;
    }

    init {
        v = 0;
    }

    next {
        call (_out') = incr(_in);
    }
}

module main {
    // rename: a_out. Lowercase to indicate instance.
    var a_out : integer; // which is equivalent to b_in
    var b_out : integer;

    instance a : A(_out : (a_out));
    instance b : B(_in : (a_out), _out : (b_out));

    init {
        a_out = 0;
        b_out = 0;
    }

    // Note: In SR, would not specify schedule, order is determined solely by compiler. here the prime notation
    // indicates that output is later than input.
    // Down the line, synthesize the scheduling logic.
    // A_out = _out, alias? If so, good match for LF.
    // Expect 0,1,2,3,4,5...
    next {
        next(a);
        next(b);
    }

    // To see the steps of the model,
    // one way to do this is by specifying
    // a false invariant and have the solvers
    // print out examples
    invariant v_lt_zero : (b.v < -100);

    control {
        v = unroll(3);
        check;
        print_results;
        v.print_cex(a_out, b_out);
    }
}
