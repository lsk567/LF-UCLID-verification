/**
 * A priority queue implementation that accepts and outputs
 * an array of data_t.
 */

module PQueue {
    type op_t = enum { PUSH, POP };
    type index_t = integer;
    type count_t = integer;
    type data_t = { integer, integer }; // { priority, val }
    type queue_t = [index_t]data_t;

    const SIZE : integer = 4;

    // Public vars
    var contents : queue_t;
    var count : count_t;
    var full : boolean;

    // Helper vars
	var __max_p__ : integer; // To store max queue index in popQ()
    var __tail__ : integer; // To store the tail idx of ret in popQ()

    input op : op_t;
    input _in : [index_t]data_t;

    output _out : [index_t]data_t;

	init {
        assume(forall (i : integer) :: (i >= 0 && i < SIZE) &&
                contents[i]._1 == 0);
		count  = 0;
		full   = false;
		__max_p__    = 0;
	}

	procedure pushQ()
		returns (
			contentsP : queue_t,
			countP : integer,
            fullP : boolean)

        // Incoming array must be smaller than SIZE
        requires (forall (i : integer) :: (i > SIZE)
                    && _in[i] == {0, 0});
        requires (forall (i : integer) :: _in[i]._1 >= 0);
        // Pre-conditions specify implications of full and !full.
		requires (!full ==> (exists (i : integer) :: (i >= 0 && i < SIZE)
                    && contents[i]._1 == 0));
		requires (full ==> (forall (i : integer) :: (i >= 0 && i < SIZE)
                    && contents[i]._1 > 0));
        ensures (!full ==> countP == count + 1);
        ensures (full ==> countP == count);
	{
        // FIXME: multiple inserts without break
        if (!full) {
            for (k : integer) in range(0, SIZE) {
                for (i : integer) in range(0, SIZE) {
                    if (contents[i]._1 == 0 && _in[k]._1 > 0) {
                        contentsP = contents[i -> _in[k]];
                        countP = count + 1;
                    }
                }
            }
        }
        if (count == SIZE) {
            fullP = true;
        }
	}

	procedure popQ()
		returns (
            ret : [index_t]data_t,
            contentsP : [index_t]data_t,
			countP : integer,
            fullP : boolean)

        requires (forall (i : integer) :: (i >= 0 && i < SIZE) && 
                    contents[i]._1 >= 0);
		ensures (countP == count - 1);
        ensures (forall (i : integer, j : integer) :: 
                    (i >= 0 && i < SIZE) &&
                    (j >= 0 && j < SIZE) &&
                    contents[i]._1 <= ret[j]._1);
        modifies __max_p__, __tail__;
	{
        // Init helper variables
        __max_p__ = 0;
        __tail__ = 0;
        contentsP = contents;
        countP = count;

        // Find the max priority
        for (i : integer) in range(0, SIZE) {
            if (contents[i]._1 > __max_p__) {
                __max_p__ = contents[i]._1;
            }
        }

        // Return all matching values
        for (i : integer) in range(0, SIZE) {
            if (contents[i]._1 == __max_p__) {
                // Set matching value to empty
                contentsP = contentsP[i -> {0, 0}];
                countP = countP - 1;

                // Add value to ret array
                ret = ret[__tail__ -> contents[i]];
                __tail__ = __tail__ + 1;
            }
        }

        if (countP < SIZE) {
            fullP = false;
        }
	}

    next {
        case
            (op == PUSH) : {
                call (contents', count', full') = pushQ();
            }
            (op == POP) : {
                call (_out', contents', count', full') = popQ();
            }
        esac;
    }

    control {
        v       = unroll(5);
        vPush   = verify(pushQ);
        vPop    = verify(popQ);
        check;
        print_results;
        v.print_cex;
        vPush.print_cex;
        vPop.print_cex;
    }
}
